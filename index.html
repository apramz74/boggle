<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Boggle</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #fff9f0;
    --bg-surface: #fff4e6;
    --tile-bg: #ffffff;
    --tile-selected: #ffdd57;
    --tile-border: #ffd6a5;
    --text-primary: #1a1a2e;
    --text-dim: #888;
    --accent-green: #06d6a0;
    --accent-red: #ef233c;
    --accent-gold: #f77f00;
    --accent-blue: #4361ee;
    --accent-pink: #f72585;
    --radius: 16px;
  }

  html, body {
    height: 100%;
    overflow: hidden;
    background: var(--bg);
    color: var(--text-primary);
    font-family: 'Fredoka', sans-serif;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100dvh;
    padding: 4px;
    background:
      radial-gradient(ellipse at 15% 10%, rgba(247, 37, 133, 0.10) 0%, transparent 50%),
      radial-gradient(ellipse at 85% 15%, rgba(67, 97, 238, 0.12) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 90%, rgba(6, 214, 160, 0.10) 0%, transparent 55%),
      #fff9f0;
  }

  /* --- TOP BAR --- */
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 560px;
    margin-bottom: 16px;
    padding: 0 4px;
  }

  .score-display {
    font-family: 'Fredoka', sans-serif;
    font-size: 32px;
    font-weight: 700;
    color: var(--accent-blue);
    letter-spacing: 0;
  }

  .timer-display {
    font-family: 'Fredoka', sans-serif;
    font-size: 26px;
    font-weight: 600;
    color: var(--text-dim);
    transition: color 0.3s;
  }
  .timer-display.urgent {
    color: var(--accent-red);
  }

  /* --- CURRENT WORD --- */
  .word-display-area {
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 8px;
    width: 100%;
    max-width: 560px;
  }

  .current-word {
    font-family: 'Fredoka', sans-serif;
    font-size: 30px;
    font-weight: 700;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent-pink);
    text-shadow: 0 2px 0 rgba(247, 37, 133, 0.18);
    transition: opacity 0.1s;
    min-height: 32px;
  }

  /* --- FEEDBACK TOAST --- */
  .feedback-toast {
    position: fixed;
    left: 50%;
    transform: translateX(-50%) translateY(-4px) scale(0.9);
    font-family: 'Fredoka', sans-serif;
    font-size: 17px;
    font-weight: 600;
    padding: 8px 22px;
    border-radius: 50px;
    opacity: 0;
    pointer-events: none;
    z-index: 100;
    transition: none;
    /* Positioned via JS relative to board top */
    top: 0;
  }
  .feedback-toast.valid {
    background: var(--accent-green);
    color: #fff;
    border: none;
    box-shadow: 0 4px 12px rgba(6, 214, 160, 0.35);
  }
  .feedback-toast.invalid {
    background: var(--accent-red);
    color: #fff;
    border: none;
    box-shadow: 0 4px 12px rgba(239, 35, 60, 0.3);
  }
  .feedback-toast.duplicate {
    background: #ccc;
    color: #555;
    border: none;
  }
  .feedback-toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0) scale(1);
    transition: opacity 0.08s ease-out, transform 0.08s ease-out;
  }
  .feedback-toast.hide {
    opacity: 0;
    transform: translateX(-50%) translateY(-4px) scale(0.95);
    transition: opacity 0.25s ease-in, transform 0.25s ease-in;
  }

  /* --- BOARD --- */
  .board-container {
    position: relative;
    width: 100%;
    max-width: 560px;
    aspect-ratio: 1;
  }

  .board {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    width: 100%;
    height: 100%;
  }

  .tile {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffffff;
    border: 3px solid #e8e0d5;
    border-radius: 18px;
    box-shadow: 0 4px 0 #d4c8b8, 0 6px 12px rgba(0,0,0,0.07);
    font-family: 'Fredoka', sans-serif;
    font-size: clamp(48px, 11vw, 90px);
    font-weight: 600;
    color: #4a5568;
    cursor: pointer;
    transform: scale(1);
    transition: background 0.06s, border-color 0.06s, box-shadow 0.06s, transform 0.06s;
    -webkit-tap-highlight-color: transparent;
    will-change: transform;
  }
  .tile.selected {
    background: #ffdd57;
    border-color: #f4a800;
    box-shadow: 0 4px 0 #d4900a, 0 6px 16px rgba(244, 168, 0, 0.35);
    color: #5a3c00;
    z-index: 2;
  }
  .tile.pop {
    animation: tilePop 0.18s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }
  .tile.unpop {
    animation: tileUnpop 0.12s ease-out forwards;
  }
  @keyframes tilePop {
    0% { transform: scale(1); }
    50% { transform: scale(1.14); }
    100% { transform: scale(1.06); }
  }
  @keyframes tileUnpop {
    0% { transform: scale(1.06); }
    100% { transform: scale(1); }
  }

  /* Score bump */
  .score-display.bump {
    animation: scoreBump 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  @keyframes scoreBump {
    0% { transform: scale(1); }
    40% { transform: scale(1.25); }
    100% { transform: scale(1); }
  }

  /* Tile result states */
  .tile.result-valid {
    background: var(--accent-green);
    border-color: #05b386;
    box-shadow: 0 4px 0 #04916c, 0 6px 16px rgba(6, 214, 160, 0.35);
    color: #fff;
    animation: tileShakeValid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-invalid {
    background: var(--accent-red);
    border-color: #c5192d;
    box-shadow: 0 4px 0 #a01224, 0 6px 16px rgba(239, 35, 60, 0.3);
    color: #fff;
    animation: tileShakeInvalid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-duplicate {
    background: #e0d8cc;
    border-color: #c8bfb4;
    box-shadow: 0 4px 0 #b0a89c;
    animation: tileShakeInvalid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-fade {
    transition: background 0.3s ease-out, border-color 0.3s ease-out, box-shadow 0.3s ease-out, color 0.3s ease-out;
  }

  @keyframes tileShakeValid {
    0% { transform: scale(1.06); }
    25% { transform: scale(1.18); }
    50% { transform: scale(1.02); }
    75% { transform: scale(1.1); }
    100% { transform: scale(1.06); }
  }
  @keyframes tileShakeInvalid {
    0% { transform: scale(1.06); }
    15% { transform: scale(1.06) translateX(-4px); }
    30% { transform: scale(1.06) translateX(4px); }
    45% { transform: scale(1.06) translateX(-3px); }
    60% { transform: scale(1.06) translateX(2px); }
    75% { transform: scale(1.06) translateX(-1px); }
    100% { transform: scale(1.06); }
  }

  /* Selection path line overlay */
  .path-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
  }
  .path-svg line {
    stroke: rgba(244, 168, 0, 0.6);
    stroke-width: 4;
    stroke-linecap: round;
  }

  /* --- START / END SCREENS --- */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(255, 249, 240, 0.96);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    overflow-y: auto;
    padding: 24px 16px;
  }
  .overlay.hidden {
    display: none;
  }

  .overlay h1 {
    font-family: 'Fredoka', sans-serif;
    font-size: 42px;
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--accent-pink);
    letter-spacing: 0.5px;
  }

  .overlay .subtitle {
    color: var(--text-dim);
    font-size: 16px;
    font-family: 'Fredoka', sans-serif;
    font-weight: 500;
    margin-bottom: 40px;
  }

  .play-btn {
    font-family: 'Fredoka', sans-serif;
    font-size: 20px;
    font-weight: 700;
    padding: 16px 52px;
    border: none;
    border-radius: 50px;
    background: var(--accent-pink);
    color: white;
    cursor: pointer;
    box-shadow: 0 5px 0 #c4006a, 0 8px 20px rgba(247, 37, 133, 0.3);
    transition: transform 0.12s, box-shadow 0.12s;
    letter-spacing: 0.5px;
  }
  .play-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 7px 0 #c4006a, 0 12px 24px rgba(247, 37, 133, 0.35);
  }
  .play-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #c4006a, 0 4px 12px rgba(247, 37, 133, 0.25);
  }

  .end-header {
    text-align: center;
    margin-bottom: 16px;
    flex-shrink: 0;
  }

  .end-score {
    font-family: 'Fredoka', sans-serif;
    font-size: 56px;
    font-weight: 700;
    color: var(--accent-gold);
    margin-bottom: 2px;
  }

  .end-ratio {
    color: var(--text-dim);
    font-size: 15px;
    font-family: 'Fredoka', sans-serif;
    font-weight: 500;
  }

  /* Accordion */
  .accordion-container {
    width: 100%;
    max-height: 65vh;
    overflow-y: auto;
    margin-bottom: 16px;
    flex: 1 1 auto;
    padding: 0 16px;
  }
  .accordion-section {
    margin-bottom: 6px;
  }
  .accordion-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    background: rgba(255,255,255,0.7);
    border: 2px solid rgba(0,0,0,0.07);
    border-radius: 12px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.12s;
  }
  .accordion-header:hover {
    background: rgba(255,255,255,0.9);
  }
  .accordion-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .accordion-header-label {
    font-family: 'Fredoka', sans-serif;
    font-size: 15px;
    font-weight: 600;
    color: var(--text-primary);
  }
  .accordion-header-count {
    font-family: 'Fredoka', sans-serif;
    font-size: 14px;
    color: var(--text-dim);
  }
  .accordion-chevron {
    width: 16px;
    height: 16px;
    position: relative;
    flex-shrink: 0;
  }
  .accordion-chevron::before,
  .accordion-chevron::after {
    content: '';
    position: absolute;
    background: var(--text-dim);
    border-radius: 1px;
    transition: transform 0.2s ease;
  }
  .accordion-chevron::before {
    width: 8px;
    height: 1.5px;
    top: 5.5px;
    left: 4px;
    transform: rotate(45deg);
  }
  .accordion-chevron::after {
    width: 8px;
    height: 1.5px;
    top: 9.5px;
    left: 4px;
    transform: rotate(-45deg);
  }
  .accordion-section.open .accordion-chevron::before {
    transform: rotate(-45deg);
  }
  .accordion-section.open .accordion-chevron::after {
    transform: rotate(45deg);
  }
  .accordion-section.open .accordion-header {
    border-radius: 12px 12px 0 0;
    border-bottom-color: transparent;
  }
  .accordion-body {
    display: none;
    padding: 6px;
    background: rgba(255,255,255,0.5);
    border: 2px solid rgba(0,0,0,0.07);
    border-top: none;
    border-radius: 0 0 12px 12px;
  }
  .accordion-section.open .accordion-body {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
    gap: 5px;
  }
  .accordion-word {
    font-family: 'Fredoka', sans-serif;
    font-size: 13px;
    font-weight: 500;
    padding: 6px 2px;
    border-radius: 8px;
    cursor: default;
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .accordion-word.found {
    background: rgba(6, 214, 160, 0.15);
    color: #04916c;
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.found:hover {
    background: rgba(6, 214, 160, 0.28);
  }
  .accordion-word.missed {
    background: rgba(0,0,0,0.04);
    color: var(--text-dim);
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.missed:hover {
    background: rgba(0,0,0,0.08);
  }

  /* Play again trigger */
  .play-again-trigger {
    font-family: 'Fredoka', sans-serif;
    font-size: 17px;
    font-weight: 600;
    color: #fff;
    background: var(--accent-blue);
    border: none;
    border-radius: 50px;
    padding: 12px 36px;
    cursor: pointer;
    flex-shrink: 0;
    box-shadow: 0 4px 0 #2d46c4, 0 6px 16px rgba(67, 97, 238, 0.3);
    transition: transform 0.12s, box-shadow 0.12s;
    -webkit-tap-highlight-color: transparent;
  }
  .play-again-trigger:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #2d46c4, 0 10px 20px rgba(67, 97, 238, 0.35);
  }
  .play-again-trigger:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #2d46c4;
  }

  /* New game modal */
  .new-game-modal {
    position: fixed;
    inset: 0;
    z-index: 400;
    display: flex;
    align-items: flex-end;
    justify-content: center;
  }
  .new-game-modal.hidden { display: none; }
  .new-game-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(26, 26, 46, 0.35);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }
  .new-game-modal-content {
    position: relative;
    z-index: 1;
    background: #fff9f0;
    border-radius: 24px 24px 0 0;
    padding: 28px 24px 36px;
    width: 100%;
    max-width: 420px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    border-top: 3px solid rgba(0,0,0,0.06);
  }
  .new-game-modal-title {
    font-family: 'Fredoka', sans-serif;
    font-size: 20px;
    font-weight: 700;
    color: var(--text-primary);
  }

  /* Word path modal */
  .word-modal {
    position: fixed;
    inset: 0;
    z-index: 500;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .word-modal.hidden { display: none; }
  .word-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(26, 26, 46, 0.55);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }
  .word-modal-content {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    z-index: 1;
    padding: 28px 24px;
  }
  .word-modal-title {
    font-family: 'Fredoka', sans-serif;
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 3px;
    color: #ffffff;
    text-shadow: 0 2px 12px rgba(0,0,0,0.3);
  }
  .word-modal-board-wrap {
    position: relative;
    width: 280px;
    height: 280px;
  }
  .word-modal-board-wrap .board {
    width: 100%;
    height: 100%;
  }
  .word-modal-board-wrap .tile {
    font-size: 16px;
  }
  .word-modal-board-wrap .tile.path-highlight {
    background: #ffdd57;
    border-color: #f4a800;
    box-shadow: 0 4px 0 #d4900a, 0 6px 14px rgba(244, 168, 0, 0.4);
    color: #5a3c00;
    z-index: 2;
  }
  .word-modal-board-wrap .path-svg line {
    stroke: rgba(244, 168, 0, 0.6);
    stroke-width: 3;
    stroke-linecap: round;
  }
  .word-modal-close {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(255,255,255,0.08);
    border-radius: 50%;
    color: var(--text-dim);
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s;
  }
  .word-modal-close:hover { background: rgba(255,255,255,0.15); }

  /* Settings */
  .settings {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-bottom: 32px;
    width: 100%;
    max-width: 360px;
  }
  .setting-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .setting-label {
    font-family: 'Fredoka', sans-serif;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-dim);
    flex-shrink: 0;
    width: 90px;
  }
  .setting-options {
    display: flex;
    gap: 6px;
  }
  .setting-options button {
    font-family: 'Fredoka', sans-serif;
    font-size: 14px;
    font-weight: 600;
    padding: 8px 14px;
    border: 2px solid #e8e0d5;
    border-radius: 50px;
    background: #fff;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.12s;
    -webkit-tap-highlight-color: transparent;
    box-shadow: 0 2px 0 #d4c8b8;
  }
  .setting-options button.active {
    background: var(--accent-blue);
    border-color: var(--accent-blue);
    color: #fff;
    box-shadow: 0 3px 0 #2d46c4;
  }
  .setting-options button:hover:not(.active) {
    border-color: var(--accent-blue);
    color: var(--accent-blue);
  }

  /* Music toggle */
  .music-toggle {
    position: fixed;
    top: 16px;
    right: 16px;
    width: 38px;
    height: 38px;
    border: 2px solid #e8e0d5;
    background: #fff;
    border-radius: 50%;
    color: var(--text-dim);
    font-size: 16px;
    cursor: pointer;
    z-index: 300;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, border-color 0.2s;
    box-shadow: 0 2px 0 #d4c8b8;
  }
  .music-toggle:hover { background: #fff9f0; border-color: var(--accent-pink); }

  /* --- CHALLENGE MODE --- */
  .challenge-btn {
    font-family: 'Fredoka', sans-serif;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 32px;
    margin-top: 12px;
    border: 2px solid #e8e0d5;
    border-radius: 50px;
    background: #fff;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.3px;
    box-shadow: 0 3px 0 #d4c8b8;
  }
  .challenge-btn:hover {
    border-color: var(--accent-blue);
    color: var(--accent-blue);
    background: rgba(67, 97, 238, 0.05);
  }

  .challenge-link-box {
    display: flex;
    gap: 8px;
    width: 100%;
    max-width: 360px;
    margin-bottom: 28px;
  }
  .challenge-link-box input {
    flex: 1;
    font-family: 'Fredoka', sans-serif;
    font-size: 13px;
    padding: 12px 14px;
    border: 2px solid #e8e0d5;
    border-radius: 12px;
    background: #fff;
    color: var(--text-primary);
    outline: none;
  }
  .copy-btn {
    font-family: 'Fredoka', sans-serif;
    font-size: 15px;
    font-weight: 600;
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    background: var(--accent-green);
    color: #fff;
    cursor: pointer;
    transition: background 0.15s;
    white-space: nowrap;
    box-shadow: 0 3px 0 #04916c;
  }
  .copy-btn:hover { background: #05b386; }

  .lobby-settings {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 32px;
    width: 100%;
    max-width: 280px;
  }
  .lobby-setting {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: #fff;
    border: 2px solid #e8e0d5;
    border-radius: 12px;
    box-shadow: 0 2px 0 #d4c8b8;
  }
  .lobby-label {
    font-family: 'Fredoka', sans-serif;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-dim);
  }
  .lobby-value {
    font-family: 'Fredoka', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--text-primary);
  }

  .waiting-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    margin: 24px 0;
    color: var(--text-dim);
    font-size: 15px;
  }
  .waiting-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid rgba(247, 37, 133, 0.2);
    border-top-color: rgba(247, 37, 133, 0.8);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .challenge-comparison-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    flex: 1;
    min-height: 0;
  }
  .challenge-comparison-wrap.hidden {
    display: none !important;
  }

  /* Racing leaderboard */
  .race-leaderboard {
    width: 100%;
    max-width: 360px;
    margin: 0 auto 16px;
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 0.4s ease, transform 0.4s ease;
  }
  .race-leaderboard.reveal {
    opacity: 1;
    transform: translateY(0);
  }
  .race-track {
    position: relative;
    height: 120px;
  }
  .race-row {
    position: absolute;
    left: 0;
    right: 0;
    height: 52px;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: top 0.45s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .race-row[data-pos="0"] { top: 0; }
  .race-row[data-pos="1"] { top: 64px; }
  .race-bar {
    display: flex;
    align-items: center;
    gap: 10px;
    height: 100%;
    border-radius: 14px;
    padding: 0 16px;
    border: 2px solid #e8e0d5;
    min-width: 52px;
    transition: width 0.35s cubic-bezier(0.25, 1, 0.5, 1),
                border-color 0.3s ease,
                box-shadow 0.3s ease;
    overflow: hidden;
    white-space: nowrap;
  }
  .race-bar.me {
    background: linear-gradient(90deg, rgba(67, 97, 238, 0.15), rgba(67, 97, 238, 0.05));
  }
  .race-bar.them {
    background: linear-gradient(90deg, rgba(247, 127, 0, 0.15), rgba(247, 127, 0, 0.05));
  }
  .race-row.leader .race-bar {
    border-color: rgba(247, 127, 0, 0.5);
    box-shadow: 0 4px 16px rgba(247, 127, 0, 0.15);
  }
  .race-rank {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Fredoka', sans-serif;
    font-size: 13px;
    font-weight: 700;
    background: rgba(0,0,0,0.06);
    color: var(--text-dim);
    flex-shrink: 0;
    transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease;
  }
  .race-row.leader .race-rank {
    background: var(--accent-gold);
    color: #fff;
    transform: scale(1.1);
  }
  .race-label {
    font-family: 'Fredoka', sans-serif;
    font-size: 15px;
    font-weight: 600;
    color: var(--text-primary);
  }
  .race-score {
    font-family: 'Fredoka', sans-serif;
    font-size: 22px;
    font-weight: 700;
    color: var(--accent-gold);
    flex-shrink: 0;
    min-width: 32px;
    text-align: right;
  }
  .race-score.bump {
    animation: scoreBump 0.2s ease;
  }
  @keyframes scoreBump {
    0% { transform: scale(1); }
    50% { transform: scale(1.25); }
    100% { transform: scale(1); }
  }

  /* Tally board area */
  .tally-board-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    opacity: 1;
    transition: opacity 0.3s ease;
  }
  .tally-board-area.hidden {
    display: none;
  }
  .tally-board-area.fade-out {
    opacity: 0;
  }
  .tally-board-wrap {
    position: relative;
    width: 200px;
    height: 200px;
  }
  .tally-board-wrap .board {
    width: 100%;
    height: 100%;
  }
  .tally-board-wrap .tile {
    font-size: 13px;
    width: auto;
    height: auto;
    min-width: 0;
    min-height: 0;
    padding: 2px;
  }
  .tally-board-wrap .path-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2;
  }
  .tile.path-highlight-me {
    background: #c084fc;
    border-color: #a855f7;
    color: #fff;
  }
  .tile.path-highlight-them {
    background: #fbbf24;
    border-color: #f59e0b;
    color: #fff;
  }
  .tile.path-highlight-both {
    background: linear-gradient(135deg, #c084fc, #fbbf24);
    border-color: #a855f7;
    color: #fff;
  }
  .tally-board-wrap .path-svg line.line-me {
    stroke: #a855f7;
    stroke-width: 3;
    stroke-linecap: round;
    opacity: 0.7;
  }
  .tally-board-wrap .path-svg line.line-them {
    stroke: #f59e0b;
    stroke-width: 3;
    stroke-linecap: round;
    opacity: 0.7;
  }
  .tally-board-wrap .path-svg line.line-both {
    stroke: url(#tallyLineGradient);
    stroke-width: 3;
    stroke-linecap: round;
    opacity: 0.7;
  }
  .tally-word-label {
    font-family: 'Fredoka', sans-serif;
    font-size: 18px;
    font-weight: 700;
    min-height: 24px;
  }
  .tally-word-label.me { color: #a855f7; }
  .tally-word-label.them { color: #f59e0b; }
  .tally-word-label.both {
    background: linear-gradient(90deg, #a855f7, #f59e0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .race-bar.burst {
    animation: barBurst 0.35s ease;
  }
  @keyframes barBurst {
    0% { transform: scaleY(1); box-shadow: none; }
    40% { transform: scaleY(1.15); box-shadow: 0 0 12px rgba(168, 85, 247, 0.5); }
    100% { transform: scaleY(1); box-shadow: none; }
  }

  .comparison-result.win { color: var(--accent-green); }
  .comparison-result.lose { color: var(--accent-red); }
  .comparison-result.tie { color: var(--accent-gold); }

  /* Word comparison chip colors */
  .accordion-word.both-found {
    background: rgba(6, 214, 160, 0.15);
    color: #04916c;
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.both-found:hover {
    background: rgba(6, 214, 160, 0.28);
  }
  .accordion-word.only-me {
    background: rgba(67, 97, 238, 0.12);
    color: var(--accent-blue);
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.only-me:hover {
    background: rgba(67, 97, 238, 0.22);
  }
  .accordion-word.only-them {
    background: rgba(247, 127, 0, 0.12);
    color: var(--accent-gold);
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.only-them:hover {
    background: rgba(247, 127, 0, 0.22);
  }
  .accordion-word.neither {
    background: rgba(0,0,0,0.04);
    color: var(--text-dim);
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.neither:hover {
    background: rgba(0,0,0,0.08);
  }

  /* --- CINEMATIC COMPARISON ANIMATIONS --- */
  @keyframes resultSlam {
    0% { opacity: 0; transform: scale(2.5); }
    50% { opacity: 1; transform: scale(0.9); }
    70% { transform: scale(1.05); }
    100% { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeSlideUp {
    0% { opacity: 0; transform: translateY(16px); }
    100% { opacity: 1; transform: translateY(0); }
  }
  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(247, 37, 133, 0.2); }
    50% { box-shadow: 0 0 40px rgba(247, 37, 133, 0.45); }
  }
  @keyframes waitingDots {
    0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
    40% { opacity: 1; transform: scale(1.2); }
  }

  /* Waiting state hero */
  .waiting-score-hero {
    font-family: 'Fredoka', sans-serif;
    font-size: 72px;
    font-weight: 700;
    color: var(--accent-pink);
    text-align: center;
    margin: 16px 0 4px;
    animation: pulseGlow 2s ease-in-out infinite;
    border-radius: 20px;
    padding: 16px 32px;
    background: rgba(247, 37, 133, 0.07);
  }
  .waiting-dots {
    display: flex;
    gap: 8px;
    justify-content: center;
    align-items: center;
    margin-top: 8px;
  }
  .waiting-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--accent-pink);
    animation: waitingDots 1.4s ease-in-out infinite;
  }
  .waiting-dot:nth-child(2) { animation-delay: 0.2s; }
  .waiting-dot:nth-child(3) { animation-delay: 0.4s; }

  .comparison-result {
    text-align: center;
    font-family: 'Fredoka', sans-serif;
    font-size: 26px;
    font-weight: 700;
    margin-bottom: 16px;
    opacity: 0;
  }
  .comparison-result.reveal {
    animation: resultSlam 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }

  /* Confetti canvas */
  #confettiCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9999;
  }

  /* Share button */
  .share-btn {
    font-family: 'Fredoka', sans-serif;
    font-size: 16px;
    font-weight: 600;
    color: #fff;
    background: var(--accent-blue);
    border: none;
    border-radius: 50px;
    padding: 10px 28px;
    cursor: pointer;
    box-shadow: 0 3px 0 #2d46c4, 0 6px 16px rgba(67, 97, 238, 0.25);
    transition: transform 0.12s, box-shadow 0.12s;
    -webkit-tap-highlight-color: transparent;
    opacity: 0;
    margin-bottom: 12px;
  }
  .share-btn.reveal {
    animation: fadeSlideUp 0.3s ease forwards;
  }
  .share-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 0 #2d46c4, 0 10px 20px rgba(67, 97, 238, 0.3);
  }
  .share-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 0 #2d46c4;
  }
  .share-btn.copied {
    background: var(--accent-green);
    box-shadow: 0 3px 0 #04916c;
  }

  /* Staggered accordion */
  .accordion-section.stagger-in {
    opacity: 0;
    animation: fadeSlideUp 0.35s ease forwards;
  }

  /* Fade-out transition for waiting state */
  #challengeWaiting {
    transition: opacity 0.3s ease;
  }
  #challengeWaiting.fading {
    opacity: 0;
  }

  .hidden { display: none !important; }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 2px; }
</style>
</head>
<body>

<button class="music-toggle" id="musicToggle">♪</button>

<!-- START SCREEN -->
<div class="overlay" id="startScreen">
  <h1>Boggle</h1>
  <p class="subtitle">swipe to find words</p>
  <div class="settings">
    <div class="setting-row">
      <span class="setting-label">Grid</span>
      <div class="setting-options" id="gridOptions">
        <button data-val="4">4×4</button>
        <button data-val="5" class="active">5×5</button>
        <button data-val="6">6×6</button>
      </div>
    </div>
    <div class="setting-row">
      <span class="setting-label">Min letters</span>
      <div class="setting-options" id="minWordOptions">
        <button data-val="3">3</button>
        <button data-val="4" class="active">4</button>
        <button data-val="5">5</button>
      </div>
    </div>
    <div class="setting-row">
      <span class="setting-label">Time</span>
      <div class="setting-options" id="timeOptions">
        <button data-val="30" class="active">0:30</button>
        <button data-val="60">1:00</button>
        <button data-val="90">1:30</button>
        <button data-val="120">2:00</button>
      </div>
    </div>
  </div>
  <button class="play-btn" id="startBtn">Play</button>
  <button class="challenge-btn" id="challengeBtn">Challenge a Friend</button>
</div>

<!-- CHALLENGE CREATED SCREEN -->
<div class="overlay hidden" id="challengeCreatedScreen">
  <h1>Challenge Ready</h1>
  <p class="subtitle">Share this link with a friend</p>
  <div class="challenge-link-box">
    <input type="text" id="challengeLink" readonly>
    <button class="copy-btn" id="copyLinkBtn">Copy</button>
  </div>
  <button class="play-btn" id="playOwnChallengeBtn">Play Now</button>
</div>

<!-- CHALLENGE LOBBY SCREEN -->
<div class="overlay hidden" id="challengeLobbyScreen">
  <h1>Challenge</h1>
  <p class="subtitle">You've been challenged!</p>
  <div class="lobby-settings">
    <div class="lobby-setting"><span class="lobby-label">Grid</span><span class="lobby-value" id="lobbyGrid">5×5</span></div>
    <div class="lobby-setting"><span class="lobby-label">Min letters</span><span class="lobby-value" id="lobbyMinWord">4</span></div>
    <div class="lobby-setting"><span class="lobby-label">Time</span><span class="lobby-value" id="lobbyTime">0:30</span></div>
  </div>
  <button class="play-btn" id="lobbyStartBtn">Start</button>
</div>

<!-- CHALLENGE END SCREEN -->
<div class="overlay hidden" id="challengeEndScreen">
  <!-- Waiting state -->
  <div id="challengeWaiting">
    <div class="end-header">
      <h1>Nice!</h1>
      <div class="waiting-score-hero" id="challengeMyScore">0</div>
      <div class="end-ratio" id="challengeMyRatio">0/0 words</div>
    </div>
    <div class="waiting-box">
      <div class="waiting-dots">
        <span class="waiting-dot"></span>
        <span class="waiting-dot"></span>
        <span class="waiting-dot"></span>
      </div>
      <p>Waiting for opponent...</p>
    </div>
  </div>
  <!-- Comparison state -->
  <div id="challengeComparison" class="hidden challenge-comparison-wrap">
    <div class="race-leaderboard" id="raceLeaderboard">
      <div class="race-track">
        <div class="race-row" id="raceBarMe" data-player="me">
          <div class="race-bar me" id="raceFillMe">
            <span class="race-rank" id="raceRankMe">1</span>
            <span class="race-label">You</span>
          </div>
          <span class="race-score" id="raceScoreMe">0</span>
        </div>
        <div class="race-row" id="raceBarThem" data-player="them">
          <div class="race-bar them" id="raceFillThem">
            <span class="race-rank" id="raceRankThem">2</span>
            <span class="race-label">Opponent</span>
          </div>
          <span class="race-score" id="raceScoreThem">0</span>
        </div>
      </div>
    </div>
    <div class="tally-board-area hidden" id="tallyBoardArea">
      <div class="tally-board-wrap" id="tallyBoardWrap">
        <svg class="path-svg" id="tallyPathSvg">
          <defs>
            <linearGradient id="tallyLineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#a855f7"/>
              <stop offset="100%" stop-color="#f59e0b"/>
            </linearGradient>
          </defs>
        </svg>
        <div class="board" id="tallyBoard"></div>
      </div>
      <div class="tally-word-label" id="tallyWordLabel"></div>
    </div>
    <div class="comparison-result" id="compResult"></div>
    <button class="share-btn" id="shareBtn">Share Results</button>
    <div class="accordion-container" id="challengeAccordionContainer"></div>
  </div>
  <button class="play-again-trigger" id="challengePlayAgain">Play again</button>
</div>

<!-- CHALLENGE ERROR SCREEN -->
<div class="overlay hidden" id="challengeErrorScreen">
  <h1>Oops</h1>
  <p class="subtitle" id="challengeErrorMsg">Challenge not found</p>
  <button class="play-btn" id="challengeErrorHomeBtn">Back to Home</button>
</div>

<!-- END SCREEN -->
<div class="overlay hidden" id="endScreen">
  <div class="end-header">
    <h1>Time's up</h1>
    <div class="end-score" id="endScore">0</div>
    <div class="end-ratio" id="endRatio">0/0 words</div>
  </div>
  <div class="accordion-container" id="accordionContainer"></div>
  <button class="play-again-trigger" id="playAgainTrigger">Play again</button>
</div>

<!-- NEW GAME MODAL -->
<div class="new-game-modal hidden" id="newGameModal">
  <div class="new-game-modal-backdrop" id="newGameModalBackdrop"></div>
  <div class="new-game-modal-content">
    <div class="new-game-modal-title">New game</div>
    <div class="settings">
      <div class="setting-row">
        <span class="setting-label">Grid</span>
        <div class="setting-options" id="gridOptions2">
          <button data-val="4">4×4</button>
          <button data-val="5" class="active">5×5</button>
          <button data-val="6">6×6</button>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Min letters</span>
        <div class="setting-options" id="minWordOptions2">
          <button data-val="3">3</button>
          <button data-val="4" class="active">4</button>
          <button data-val="5">5</button>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Time</span>
        <div class="setting-options" id="timeOptions2">
          <button data-val="30" class="active">0:30</button>
          <button data-val="60">1:00</button>
          <button data-val="90">1:30</button>
          <button data-val="120">2:00</button>
        </div>
      </div>
    </div>
    <button class="play-btn" id="replayBtn">Play</button>
  </div>
</div>

<!-- WORD PATH MODAL -->
<div class="word-modal hidden" id="wordModal">
  <div class="word-modal-backdrop" id="wordModalBackdrop"></div>
  <div class="word-modal-content">
    <div class="word-modal-title" id="wordModalTitle">WORD</div>
    <div class="word-modal-board-wrap">
      <svg class="path-svg" id="modalPathSvg"></svg>
      <div class="board" id="modalBoard"></div>
    </div>
    <button class="word-modal-close" id="wordModalClose">✕</button>
  </div>
</div>

<!-- GAME UI -->
<div class="top-bar" id="gameUI" style="visibility: hidden;">
  <div class="score-display" id="score">0</div>
  <div class="timer-display" id="timer">0:30</div>
</div>

<div class="word-display-area" id="wordArea" style="visibility: hidden;">
  <div class="current-word" id="currentWord"></div>
</div>

<div class="board-container" id="boardContainer" style="visibility: hidden;">
  <svg class="path-svg" id="pathSvg"></svg>
  <div class="board" id="board"></div>
</div>

<div class="feedback-toast" id="toast"></div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>

<!-- Dictionary (extracted for maintainability) -->
<script src="dictionary.js"></script>

<script>
// ========== FIREBASE ==========
const firebaseConfig = {
  apiKey: "AIzaSyC-vMDhqfm_vMcJ2WBWNX-AMcHLfBaP66Q",
  authDomain: "boggle-351dc.firebaseapp.com",
  projectId: "boggle-351dc",
  storageBucket: "boggle-351dc.firebasestorage.app",
  messagingSenderId: "864208454720",
  appId: "1:864208454720:web:be8d95204b468c4b090ba5",
  measurementId: "G-VE9BT1CSMZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

function getPlayerId() {
  let id = localStorage.getItem('boggle_player_id');
  if (!id) {
    id = crypto.randomUUID();
    localStorage.setItem('boggle_player_id', id);
  }
  return id;
}
const MY_PLAYER_ID = getPlayerId();

// ========== CHALLENGE STATE ==========
let challengeMode = false;
let currentChallengeId = null;
let currentChallengeData = null;
let challengeUnsubscribe = null; // onSnapshot listener cleanup

// ========== DICTIONARY ==========
// ~67k common English words (SCOWL size 55), gzip compressed + base64 encoded
// Dictionary loaded from dictionary.js

let VALID_WORDS = new Set();
let PREFIX_SET = new Set();
let dictionaryReady = false;

async function loadDictionary() {
  try {
    const binary = Uint8Array.from(atob(DICT_GZ_B64), c => c.charCodeAt(0));
    const ds = new DecompressionStream('gzip');
    const writer = ds.writable.getWriter();
    writer.write(binary);
    writer.close();
    const reader = ds.readable.getReader();
    const chunks = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }
    const totalLen = chunks.reduce((a, c) => a + c.length, 0);
    const merged = new Uint8Array(totalLen);
    let offset = 0;
    for (const chunk of chunks) {
      merged.set(chunk, offset);
      offset += chunk.length;
    }
    const csv = new TextDecoder().decode(merged);
    const words = csv.split(',');
    VALID_WORDS = new Set(words);
    
    // Build prefix set for fast DFS pruning
    PREFIX_SET = new Set();
    for (const word of words) {
      for (let i = 1; i <= word.length; i++) {
        PREFIX_SET.add(word.substring(0, i));
      }
    }
    
    dictionaryReady = true;
    console.log('Dictionary loaded:', VALID_WORDS.size, 'words,', PREFIX_SET.size, 'prefixes');
  } catch (e) {
    console.error('Dict load failed:', e);
  }
}

// ========== BOARD GENERATION ==========
// Classic Boggle dice - carefully designed letter distributions
const BOGGLE_DICE_4x4 = [
  'AAEEGN','ABBJOO','ACHOPS','AFFKPS',
  'AOOTTW','CIMOTU','DEILRX','DELRVY',
  'DISTTY','EEGHNW','EEINSU','EHRTVW',
  'EIOSST','ELRTTY','HIMNUQ','HLNNRZ'
];
const BOGGLE_DICE_5x5 = [
  'AAAFRS','AAEEEE','AAFIRS','ADENNN','AEEEEM',
  'AEEGMU','AEGMNN','AFIRSY','BJKQXZ','CCNSTW',
  'CEIILT','CEILPT','CEIPST','DDLNOR','DHHLOR',
  'DHHNOT','DHLNOR','EIIITT','EMOTTT','ENSSSU',
  'FIPRSY','GORRVW','HIPRRY','NOOTUW','OOOTTU'
];
// 6x6: combine 5x5 dice + extra dice with good letter distributions
const BOGGLE_DICE_6x6 = [
  ...BOGGLE_DICE_5x5,
  'AAAFRS','AEEGMU','CEIILT','EMOTTT','ENSSSU',
  'ADENNN','DHLNOR','EIIITT','GORRVW','NOOTUW',
  'DHHLOR'
];

function rollDice(diceSet, count) {
  const shuffled = [...diceSet];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  const board = [];
  for (let i = 0; i < count; i++) {
    const die = shuffled[i % shuffled.length];
    board.push(die[Math.floor(Math.random() * die.length)]);
  }
  return board;
}

// Configurable settings
let GRID_SIZE = 5;
let MIN_WORD_LENGTH = 4;

function generateBoard() {
  const totalTiles = GRID_SIZE * GRID_SIZE;
  const diceSet = GRID_SIZE === 4 ? BOGGLE_DICE_4x4 : GRID_SIZE === 5 ? BOGGLE_DICE_5x5 : BOGGLE_DICE_6x6;

  // Only reroll if a board is genuinely unplayable — not to cherry-pick the best
  const minWords = GRID_SIZE === 4 ? 30 : GRID_SIZE === 5 ? 100 : 200;
  const maxAttempts = 5;

  let board = null;
  let bestBoard = null;
  let bestWordCount = 0;

  for (let i = 0; i < maxAttempts; i++) {
    const candidate = rollDice(diceSet, totalTiles);
    const wordCount = findAllWords(candidate).words.size;
    if (wordCount > bestWordCount) {
      bestWordCount = wordCount;
      bestBoard = candidate;
    }
    if (wordCount >= minWords) {
      board = candidate;
      break;
    }
  }

  if (!board) board = bestBoard;

  console.log('Board generated with', bestWordCount, 'possible words');
  return board;
}

function getNeighbors(idx) {
  const r = Math.floor(idx / GRID_SIZE), c = idx % GRID_SIZE;
  const neighbors = [];
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) neighbors.push(nr * GRID_SIZE + nc);
    }
  }
  return neighbors;
}

function buildNeighborMap() {
  const totalTiles = GRID_SIZE * GRID_SIZE;
  const map = [];
  for (let i = 0; i < totalTiles; i++) map.push(getNeighbors(i));
  return map;
}

let NEIGHBOR_MAP = buildNeighborMap();

function findAllWords(board) {
  const found = new Set();
  const wordPaths = {};
  const totalTiles = GRID_SIZE * GRID_SIZE;

  function dfs(idx, path, word) {
    const letter = board[idx].toLowerCase();
    word += letter === 'q' ? 'qu' : letter;
    // Prune: if no words start with this prefix, stop exploring
    if (!PREFIX_SET.has(word)) return;
    if (word.length >= MIN_WORD_LENGTH && VALID_WORDS.has(word)) {
      if (!found.has(word)) {
        found.add(word);
        wordPaths[word] = [...path];
      }
    }
    if (word.length >= 8) return;
    for (const n of NEIGHBOR_MAP[idx]) {
      if (!path.has(n)) {
        path.add(n);
        dfs(n, path, word);
        path.delete(n);
      }
    }
  }

  for (let i = 0; i < totalTiles; i++) {
    const path = new Set([i]);
    dfs(i, path, '');
  }
  return { words: found, paths: wordPaths };
}

// ========== SCORING ==========
function scoreWord(word) {
  const len = word.length;
  if (len <= 3) return 1;
  if (len === 4) return 1;
  if (len === 5) return 2;
  if (len === 6) return 3;
  if (len === 7) return 5;
  return 11;
}

// ========== GAME STATE ==========
let board = [];
let validWordsOnBoard = new Set();
let allWordPaths = {};
let foundWords = new Set();
let selectedPath = [];
let isSelecting = false;
let totalScore = 0;
let timerSeconds = 30;
let timerInterval = null;
let gameActive = false;

// ========== AUDIO ==========
let audioCtx = null;
let musicPlaying = false;
let musicNodes = [];

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTick() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Percussive click: short noise burst + pitched blip
  const bufferSize = audioCtx.sampleRate * 0.015;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 8);
  }
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.12, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = 'bandpass';
  noiseFilter.frequency.value = 4000;
  noiseFilter.Q.value = 1.5;
  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noise.start(now);
  noise.stop(now + 0.02);

  // Tonal blip
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.setValueAtTime(880 + Math.random() * 300, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.04);
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
  osc.start(now);
  osc.stop(now + 0.05);
}

function playValidSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Bright ascending arpeggio with harmonics
  const notes = [523, 659, 784, 1047];
  notes.forEach((freq, i) => {
    const t = now + i * 0.045;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = 'triangle';
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc.start(t);
    osc.stop(t + 0.2);
  });
  // Satisfying shimmer
  const shimmer = audioCtx.createOscillator();
  const sGain = audioCtx.createGain();
  shimmer.connect(sGain);
  sGain.connect(audioCtx.destination);
  shimmer.frequency.value = 1568;
  shimmer.type = 'sine';
  sGain.gain.setValueAtTime(0.04, now + 0.12);
  sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  shimmer.start(now + 0.12);
  shimmer.stop(now + 0.5);
}

function playInvalidSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Dull thud
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.setValueAtTime(150, now);
  osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.12, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
  osc.start(now);
  osc.stop(now + 0.13);
}

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;

  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.18;
  masterGain.connect(audioCtx.destination);
  musicNodes.push(masterGain);

  // Chord progression: Am - F - C - G (looping)
  const chords = [
    [220.0, 261.6, 329.6],   // Am
    [174.6, 220.0, 261.6],   // F
    [130.8, 164.8, 196.0],   // C low
    [196.0, 246.9, 293.7],   // G
  ];

  const bpm = 72;
  const beatDur = 60 / bpm;
  const chordDur = beatDur * 4; // 4 beats per chord
  const loopDur = chordDur * chords.length;

  // Soft pad layer
  function schedulePad() {
    const now = audioCtx.currentTime;
    chords.forEach((notes, ci) => {
      const startT = now + ci * chordDur;
      notes.forEach(freq => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq * 0.5;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0, startT);
        g.gain.linearRampToValueAtTime(0.25, startT + 0.4);
        g.gain.setValueAtTime(0.25, startT + chordDur - 0.4);
        g.gain.linearRampToValueAtTime(0, startT + chordDur);
        osc.connect(g);
        g.connect(masterGain);
        osc.start(startT);
        osc.stop(startT + chordDur + 0.1);
        musicNodes.push(osc, g);
      });
    });
  }

  // Arpeggio layer — gentle plucked notes
  function scheduleArpeggio() {
    const now = audioCtx.currentTime;
    const arpPatterns = [
      [440, 523.3, 659.3, 523.3, 440, 523.3, 659.3, 523.3],     // Am
      [349.2, 440, 523.3, 440, 349.2, 440, 523.3, 440],          // F
      [261.6, 329.6, 392, 329.6, 261.6, 329.6, 392, 329.6],      // C
      [392, 493.9, 587.3, 493.9, 392, 493.9, 587.3, 493.9],      // G
    ];
    arpPatterns.forEach((pattern, ci) => {
      const chordStart = now + ci * chordDur;
      pattern.forEach((freq, ni) => {
        const t = chordStart + ni * (chordDur / pattern.length);
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + beatDur * 1.2);
        osc.connect(g);
        g.connect(masterGain);
        osc.start(t);
        osc.stop(t + beatDur * 1.5);
        musicNodes.push(osc, g);
      });
    });
  }

  // Subtle bass note per chord
  function scheduleBass() {
    const now = audioCtx.currentTime;
    const bassNotes = [110, 87.3, 65.4, 98];
    bassNotes.forEach((freq, ci) => {
      const t = now + ci * chordDur;
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.3, t);
      g.gain.exponentialRampToValueAtTime(0.05, t + chordDur * 0.8);
      g.gain.linearRampToValueAtTime(0, t + chordDur);
      osc.connect(g);
      g.connect(masterGain);
      osc.start(t);
      osc.stop(t + chordDur + 0.1);
      musicNodes.push(osc, g);
    });
  }

  // Schedule first loop
  schedulePad();
  scheduleArpeggio();
  scheduleBass();

  // Re-schedule on loop
  musicLoopInterval = setInterval(() => {
    if (!musicPlaying) return;
    schedulePad();
    scheduleArpeggio();
    scheduleBass();
  }, loopDur * 1000);
  musicNodes.push({ stop: () => clearInterval(musicLoopInterval) });
}

let musicLoopInterval = null;

function stopMusic() {
  musicPlaying = false;
  clearInterval(musicLoopInterval);
  musicNodes.forEach(n => { try { n.stop ? n.stop() : n.disconnect(); } catch(e){} });
  musicNodes = [];
}

// ========== HAPTICS ==========
function hapticTick() {
  if (navigator.vibrate) navigator.vibrate(8);
}
function hapticSuccess() {
  if (navigator.vibrate) navigator.vibrate([15, 30, 15]);
}
function hapticError() {
  if (navigator.vibrate) navigator.vibrate([40]);
}

// ========== DOM ==========
const boardEl = document.getElementById('board');
const pathSvg = document.getElementById('pathSvg');
const currentWordEl = document.getElementById('currentWord');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const toastEl = document.getElementById('toast');
const startScreen = document.getElementById('startScreen');
const endScreen = document.getElementById('endScreen');
const gameUI = document.getElementById('gameUI');
const wordArea = document.getElementById('wordArea');
const boardContainer = document.getElementById('boardContainer');
const musicToggle = document.getElementById('musicToggle');

function renderBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  // Adjust gap for grid density; font size handled by CSS
  const gaps = { 4: 14, 5: 10, 6: 8 };
  boardEl.style.gap = (gaps[GRID_SIZE] || 10) + 'px';
  board.forEach((letter, i) => {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.textContent = letter === 'Q' ? 'Qu' : letter;
    tile.dataset.index = i;
    boardEl.appendChild(tile);
  });
}

function getTileCenter(idx) {
  const tile = boardEl.children[idx];
  if (!tile) return { x: 0, y: 0 };
  const boardRect = boardContainer.getBoundingClientRect();
  const tileRect = tile.getBoundingClientRect();
  return {
    x: ((tileRect.left + tileRect.width / 2 - boardRect.left) / boardRect.width) * 100 + '%',
    y: ((tileRect.top + tileRect.height / 2 - boardRect.top) / boardRect.height) * 100 + '%'
  };
}

function updatePathSvg() {
  pathSvg.innerHTML = '';
  for (let i = 1; i < selectedPath.length; i++) {
    const from = getTileCenter(selectedPath[i - 1]);
    const to = getTileCenter(selectedPath[i]);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', from.x);
    line.setAttribute('y1', from.y);
    line.setAttribute('x2', to.x);
    line.setAttribute('y2', to.y);
    pathSvg.appendChild(line);
  }
}

let prevSelectedSet = new Set();

function updateSelection() {
  const tiles = boardEl.children;
  const selectedSet = new Set(selectedPath);

  for (let i = 0; i < tiles.length; i++) {
    const wasSelected = prevSelectedSet.has(i);
    const isSelected = selectedSet.has(i);
    tiles[i].classList.toggle('selected', isSelected);

    if (isSelected && !wasSelected) {
      // Newly selected — pop in
      tiles[i].classList.remove('unpop');
      tiles[i].classList.remove('pop');
      void tiles[i].offsetWidth; // force reflow
      tiles[i].classList.add('pop');
    } else if (!isSelected && wasSelected) {
      // Deselected — pop out
      tiles[i].classList.remove('pop');
      tiles[i].classList.remove('unpop');
      void tiles[i].offsetWidth;
      tiles[i].classList.add('unpop');
    }
  }

  prevSelectedSet = new Set(selectedSet);
  const word = selectedPath.map(i => board[i] === 'Q' ? 'QU' : board[i]).join('');
  currentWordEl.textContent = word;
  updatePathSvg();
}

function getTileFromPoint(x, y) {
  const tiles = boardEl.children;
  for (let i = 0; i < tiles.length; i++) {
    const rect = tiles[i].getBoundingClientRect();
    // Inset the hit target so edges don't trigger — helps diagonal swiping
    const inset = rect.width * 0.12;
    if (x >= rect.left + inset && x <= rect.right - inset && y >= rect.top + inset && y <= rect.bottom - inset) {
      return i;
    }
  }
  return -1;
}

function isAdjacent(a, b) {
  return NEIGHBOR_MAP[a].includes(b);
}

// ========== INPUT HANDLING ==========
function onSelectStart(x, y) {
  if (!gameActive) return;
  const idx = getTileFromPoint(x, y);
  if (idx < 0) return;
  isSelecting = true;
  selectedPath = [idx];
  playTick();
  updateSelection();
}

function onSelectMove(x, y) {
  if (!isSelecting || !gameActive) return;
  const idx = getTileFromPoint(x, y);
  if (idx < 0) return;

  const lastIdx = selectedPath[selectedPath.length - 1];
  if (idx === lastIdx) return;

  // Allow backtracking
  if (selectedPath.length >= 2 && idx === selectedPath[selectedPath.length - 2]) {
    selectedPath.pop();
    playTick();
    updateSelection();
    return;
  }

  if (selectedPath.includes(idx)) return;
  if (!isAdjacent(lastIdx, idx)) return;

  selectedPath.push(idx);
  playTick();
  updateSelection();
}

function onSelectEnd() {
  if (!isSelecting || !gameActive) return;
  isSelecting = false;
  submitWord();
}

let resultTimeout = null;

function showTileResult(indices, resultClass) {
  clearTimeout(resultTimeout);
  const tiles = boardEl.children;

  // Apply result state to the selected tiles
  indices.forEach(idx => {
    tiles[idx].classList.remove('pop', 'unpop', 'selected');
    tiles[idx].classList.add(resultClass);
  });

  // After animation, fade back to default
  resultTimeout = setTimeout(() => {
    indices.forEach(idx => {
      tiles[idx].classList.add('result-fade');
      tiles[idx].classList.remove(resultClass);
    });
    // Clean up transition class
    setTimeout(() => {
      indices.forEach(idx => {
        tiles[idx].classList.remove('result-fade');
      });
    }, 300);
  }, 350);
}

function submitWord() {
  const word = selectedPath.map(i => board[i] === 'Q' ? 'QU' : board[i]).join('').toLowerCase();
  const submittedPath = [...selectedPath];
  prevSelectedSet = new Set();
  selectedPath = [];
  currentWordEl.textContent = '';
  updatePathSvg();

  // Clear selection styling (but don't unpop — we'll show result state instead)
  const tiles = boardEl.children;
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].classList.remove('selected', 'pop', 'unpop');
  }

  if (word.length < 3) return;

  if (word.length < MIN_WORD_LENGTH) {
    showToast(`${MIN_WORD_LENGTH} letters min`, 'invalid');
    showTileResult(submittedPath, 'result-invalid');
    playInvalidSound();
    return;
  }

  if (foundWords.has(word)) {
    showToast('Already found', 'duplicate');
    showTileResult(submittedPath, 'result-duplicate');
    playInvalidSound();
    return;
  }

  if (validWordsOnBoard.has(word)) {
    foundWords.add(word);
    const pts = scoreWord(word);
    totalScore += pts;
    scoreEl.textContent = totalScore;
    scoreEl.classList.remove('bump');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('bump');
    showToast(`+${pts}`, 'valid');
    showTileResult(submittedPath, 'result-valid');
    playValidSound();
  } else {
    showToast('Not a word', 'invalid');
    showTileResult(submittedPath, 'result-invalid');
    playInvalidSound();
  }
}

let toastTimeout = null;
function showToast(msg, type) {
  clearTimeout(toastTimeout);
  // Position above the board
  const boardRect = boardContainer.getBoundingClientRect();
  toastEl.style.top = (boardRect.top - 70) + 'px';
  toastEl.className = 'feedback-toast ' + type;
  toastEl.textContent = msg;
  toastEl.offsetHeight;
  toastEl.classList.add('show');

  toastTimeout = setTimeout(() => {
    toastEl.classList.remove('show');
    toastEl.classList.add('hide');
  }, 600);
}

// Touch events
boardContainer.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  onSelectStart(t.clientX, t.clientY);
}, { passive: false });

boardContainer.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  onSelectMove(t.clientX, t.clientY);
}, { passive: false });

boardContainer.addEventListener('touchend', e => {
  e.preventDefault();
  onSelectEnd();
}, { passive: false });

// Mouse events (for desktop)
boardContainer.addEventListener('mousedown', e => {
  onSelectStart(e.clientX, e.clientY);
});
window.addEventListener('mousemove', e => {
  onSelectMove(e.clientX, e.clientY);
});
window.addEventListener('mouseup', () => {
  onSelectEnd();
});

// ========== TIMER ==========
function updateTimerDisplay() {
  const m = Math.floor(timerSeconds / 60);
  const s = timerSeconds % 60;
  timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  timerEl.classList.toggle('urgent', timerSeconds <= 15);
}

function startTimer() {
  updateTimerDisplay();
  timerInterval = setInterval(() => {
    timerSeconds--;
    updateTimerDisplay();
    if (timerSeconds <= 0) {
      endGame();
    }
  }, 1000);
}

// ========== GAME FLOW ==========
async function startGame() {
  initAudio();

  let gameDuration;

  if (challengeMode && currentChallengeData) {
    // Challenge mode: use settings from Firestore
    GRID_SIZE = currentChallengeData.gridSize;
    MIN_WORD_LENGTH = currentChallengeData.minWordLength;
    gameDuration = currentChallengeData.timeSeconds;
  } else {
    // Solo mode: read settings from UI
    const gridBtn = document.querySelector('#startScreen:not(.hidden) #gridOptions button.active, #newGameModal:not(.hidden) #gridOptions2 button.active');
    const minBtn = document.querySelector('#startScreen:not(.hidden) #minWordOptions button.active, #newGameModal:not(.hidden) #minWordOptions2 button.active');
    const timeBtn = document.querySelector('#startScreen:not(.hidden) #timeOptions button.active, #newGameModal:not(.hidden) #timeOptions2 button.active');
    GRID_SIZE = parseInt(gridBtn?.dataset.val || '5');
    MIN_WORD_LENGTH = parseInt(minBtn?.dataset.val || '4');
    gameDuration = parseInt(timeBtn?.dataset.val || '30');
  }

  NEIGHBOR_MAP = buildNeighborMap();

  // Sync both setting screens
  document.querySelectorAll('#gridOptions button, #gridOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(GRID_SIZE));
  });
  document.querySelectorAll('#minWordOptions button, #minWordOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(MIN_WORD_LENGTH));
  });
  document.querySelectorAll('#timeOptions button, #timeOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(gameDuration));
  });

  // Load dictionary on first play
  if (!dictionaryReady) {
    document.getElementById('startBtn').textContent = 'Loading...';
    document.getElementById('replayBtn').textContent = 'Loading...';
    await loadDictionary();
    document.getElementById('startBtn').textContent = 'Play';
    document.getElementById('replayBtn').textContent = 'Play';
  }

  // Hide all overlays
  startScreen.classList.add('hidden');
  endScreen.classList.add('hidden');
  document.getElementById('newGameModal').classList.add('hidden');
  document.getElementById('challengeCreatedScreen').classList.add('hidden');
  document.getElementById('challengeLobbyScreen').classList.add('hidden');
  document.getElementById('challengeEndScreen').classList.add('hidden');
  document.getElementById('challengeErrorScreen').classList.add('hidden');
  gameUI.style.visibility = 'visible';
  wordArea.style.visibility = 'visible';
  boardContainer.style.visibility = 'visible';

  if (challengeMode && currentChallengeData) {
    // Use board from challenge data
    board = currentChallengeData.board;
  } else {
    board = generateBoard();
  }

  const solveResult = findAllWords(board);
  validWordsOnBoard = solveResult.words;
  allWordPaths = solveResult.paths;
  foundWords = new Set();
  selectedPath = [];
  prevSelectedSet = new Set();
  totalScore = 0;
  timerSeconds = gameDuration;
  scoreEl.textContent = '0';
  pathSvg.innerHTML = '';

  renderBoard();
  startTimer();
  startMusic();
  gameActive = true;
}

function endGame() {
  gameActive = false;
  clearInterval(timerInterval);
  stopMusic();

  gameUI.style.visibility = 'hidden';
  wordArea.style.visibility = 'hidden';
  boardContainer.style.visibility = 'hidden';

  if (challengeMode && currentChallengeId) {
    endChallengeGame();
    return;
  }

  // Solo mode end screen
  showSoloEndScreen();
}

function showSoloEndScreen() {
  document.getElementById('endScore').textContent = totalScore;
  const totalPossible = validWordsOnBoard.size;
  document.getElementById('endRatio').textContent = `${foundWords.size}/${totalPossible} words`;

  const container = document.getElementById('accordionContainer');
  container.innerHTML = '';
  buildWordAccordion(container, validWordsOnBoard, foundWords);
  endScreen.classList.remove('hidden');
}

function buildWordAccordion(container, allWords, myWords, theirWords, stagger = false) {
  const isComparison = !!theirWords;
  const byLength = {};
  for (const w of allWords) {
    const len = w.length;
    if (len < MIN_WORD_LENGTH) continue;
    if (!byLength[len]) byLength[len] = [];
    byLength[len].push(w);
  }

  const lengths = Object.keys(byLength).map(Number).sort((a, b) => a - b);

  lengths.forEach((len, index) => {
    const words = byLength[len].sort();
    const foundInGroup = words.filter(w => myWords.has(w));
    const section = document.createElement('div');
    section.className = 'accordion-section';
    if (stagger) {
      section.classList.add('stagger-in');
      section.style.animationDelay = `${index * 0.08}s`;
    }

    const header = document.createElement('div');
    header.className = 'accordion-header';
    header.innerHTML = `
      <div class="accordion-header-left">
        <span class="accordion-header-label">${len}-letter</span>
        <span class="accordion-header-count">${foundInGroup.length}/${words.length}</span>
      </div>
      <div class="accordion-chevron"></div>
    `;
    header.addEventListener('click', () => section.classList.toggle('open'));

    const body = document.createElement('div');
    body.className = 'accordion-body';

    words.forEach(w => {
      const chip = document.createElement('span');
      if (isComparison) {
        const iFound = myWords.has(w);
        const theyFound = theirWords.has(w);
        if (iFound && theyFound) chip.className = 'accordion-word both-found';
        else if (iFound) chip.className = 'accordion-word only-me';
        else if (theyFound) chip.className = 'accordion-word only-them';
        else chip.className = 'accordion-word neither';
      } else {
        chip.className = 'accordion-word ' + (myWords.has(w) ? 'found' : 'missed');
      }
      chip.textContent = w;
      chip.addEventListener('click', () => showWordPath(w));
      body.appendChild(chip);
    });

    section.appendChild(header);
    section.appendChild(body);
    container.appendChild(section);

    // Auto-open first section
    if (stagger && index === 0) {
      section.classList.add('open');
    }
  });
}

// ========== CHALLENGE MODE FUNCTIONS ==========

async function createChallenge() {
  const gridBtn = document.querySelector('#startScreen #gridOptions button.active');
  const minBtn = document.querySelector('#startScreen #minWordOptions button.active');
  const timeBtn = document.querySelector('#startScreen #timeOptions button.active');
  const gridSize = parseInt(gridBtn?.dataset.val || '5');
  const minWordLength = parseInt(minBtn?.dataset.val || '4');
  const timeSeconds = parseInt(timeBtn?.dataset.val || '30');

  // Set globals for board generation
  GRID_SIZE = gridSize;
  MIN_WORD_LENGTH = minWordLength;
  NEIGHBOR_MAP = buildNeighborMap();

  // Load dictionary if needed
  if (!dictionaryReady) {
    document.getElementById('challengeBtn').textContent = 'Loading...';
    await loadDictionary();
    document.getElementById('challengeBtn').textContent = 'Challenge a Friend';
  }

  // Generate board
  const challengeBoard = generateBoard();
  const solveResult = findAllWords(challengeBoard);

  // Create Firestore document
  const docRef = await db.collection('challenges').add({
    board: challengeBoard,
    gridSize: gridSize,
    minWordLength: minWordLength,
    timeSeconds: timeSeconds,
    totalValidWords: solveResult.words.size,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    players: {}
  });

  currentChallengeId = docRef.id;
  currentChallengeData = {
    board: challengeBoard,
    gridSize: gridSize,
    minWordLength: minWordLength,
    timeSeconds: timeSeconds,
    totalValidWords: solveResult.words.size,
    players: {}
  };
  challengeMode = true;

  // Build shareable link
  const url = `${location.origin}${location.pathname}?c=${docRef.id}`;
  document.getElementById('challengeLink').value = url;

  // Show challenge created screen
  startScreen.classList.add('hidden');
  document.getElementById('challengeCreatedScreen').classList.remove('hidden');
}

async function joinChallenge(challengeId) {
  try {
    const doc = await db.collection('challenges').doc(challengeId).get();
    if (!doc.exists) {
      showChallengeError('Challenge not found');
      return;
    }

    const data = doc.data();
    currentChallengeId = challengeId;
    currentChallengeData = data;
    challengeMode = true;

    // Check if this player already played
    if (data.players && data.players[MY_PLAYER_ID]) {
      // Already played — show results
      showChallengeResults(data);
      return;
    }

    // Check if 2 players already played
    const playerIds = data.players ? Object.keys(data.players) : [];
    if (playerIds.length >= 2) {
      showChallengeError('This challenge is full');
      return;
    }

    // Show lobby
    const m = Math.floor(data.timeSeconds / 60);
    const s = data.timeSeconds % 60;
    document.getElementById('lobbyGrid').textContent = `${data.gridSize}×${data.gridSize}`;
    document.getElementById('lobbyMinWord').textContent = data.minWordLength;
    document.getElementById('lobbyTime').textContent = `${m}:${s.toString().padStart(2, '0')}`;

    startScreen.classList.add('hidden');
    document.getElementById('challengeLobbyScreen').classList.remove('hidden');
  } catch (err) {
    console.error('Join challenge error:', err);
    showChallengeError('Failed to load challenge. Please try again.');
  }
}

function showChallengeError(msg) {
  document.getElementById('challengeErrorMsg').textContent = msg;
  startScreen.classList.add('hidden');
  document.getElementById('challengeErrorScreen').classList.remove('hidden');
}

async function endChallengeGame() {
  // Write results to Firestore
  const myResult = {
    score: totalScore,
    wordsFound: [...foundWords],
    wordCount: foundWords.size,
    completedAt: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await db.collection('challenges').doc(currentChallengeId).update({
      [`players.${MY_PLAYER_ID}`]: myResult
    });
  } catch (err) {
    console.error('Failed to save results:', err);
    showChallengeError('Failed to save your results. Please try again.');
    return;
  }

  // Fetch latest state
  const doc = await db.collection('challenges').doc(currentChallengeId).get();
  const data = doc.data();
  currentChallengeData = data;

  showChallengeResults(data);
}

async function showChallengeResults(data) {
  const challengeEndEl = document.getElementById('challengeEndScreen');
  const waitingEl = document.getElementById('challengeWaiting');
  const compEl = document.getElementById('challengeComparison');

  const myData = data.players?.[MY_PLAYER_ID];
  const opponentId = Object.keys(data.players || {}).find(id => id !== MY_PLAYER_ID);
  const opponentData = opponentId ? data.players[opponentId] : null;

  // Set up validWordsOnBoard if not already (for comparison accordion word paths)
  if (!validWordsOnBoard || validWordsOnBoard.size === 0) {
    await loadDictionary();
    GRID_SIZE = data.gridSize;
    MIN_WORD_LENGTH = data.minWordLength;
    NEIGHBOR_MAP = buildNeighborMap();
    board = data.board;
    const solveResult = findAllWords(board);
    validWordsOnBoard = solveResult.words;
    allWordPaths = solveResult.paths;
  }

  function fadeToComparison(myD, theirD, challengeD) {
    waitingEl.classList.add('fading');
    setTimeout(() => {
      waitingEl.classList.add('hidden');
      waitingEl.classList.remove('fading');
      compEl.classList.remove('hidden');
      renderComparison(myD, theirD, challengeD);
    }, 300);
  }

  if (opponentData) {
    // Show comparison (skip fade if waiting wasn't visible)
    if (!waitingEl.classList.contains('hidden')) {
      fadeToComparison(myData, opponentData, data);
    } else {
      waitingEl.classList.add('hidden');
      compEl.classList.remove('hidden');
      renderComparison(myData, opponentData, data);
    }
  } else {
    // Show waiting state
    waitingEl.classList.remove('hidden');
    waitingEl.classList.remove('fading');
    compEl.classList.add('hidden');

    document.getElementById('challengeMyScore').textContent = myData?.score ?? 0;
    document.getElementById('challengeMyRatio').textContent =
      `${myData?.wordCount ?? 0}/${data.totalValidWords} words`;

    // Listen for opponent
    if (challengeUnsubscribe) challengeUnsubscribe();
    challengeUnsubscribe = db.collection('challenges').doc(currentChallengeId)
      .onSnapshot(snap => {
        const updated = snap.data();
        const oppId = Object.keys(updated.players || {}).find(id => id !== MY_PLAYER_ID);
        if (oppId && updated.players[oppId]) {
          if (challengeUnsubscribe) challengeUnsubscribe();
          challengeUnsubscribe = null;
          currentChallengeData = updated;
          fadeToComparison(updated.players[MY_PLAYER_ID], updated.players[oppId], updated);
        }
      });
  }

  challengeEndEl.classList.remove('hidden');
}

// ========== CINEMATIC COMPARISON UTILITIES ==========
let comparisonTimeouts = [];

function animateCountUp(el, target, duration) {
  const start = performance.now();
  const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  function tick(now) {
    const elapsed = now - start;
    const progress = Math.min(elapsed / duration, 1);
    el.textContent = Math.round(ease(progress) * target);
    if (progress < 1) requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

function launchConfetti() {
  const canvas = document.getElementById('confettiCanvas');
  if (!canvas) return;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const ctx = canvas.getContext('2d');
  const particles = [];
  const colors = ['#5ce0a0', '#a78bfa', '#f0c060', '#ff6b7a', '#60b0f0', '#ffffff'];

  for (let i = 0; i < 80; i++) {
    particles.push({
      x: canvas.width * 0.5 + (Math.random() - 0.5) * 100,
      y: canvas.height * 0.4,
      vx: (Math.random() - 0.5) * 16,
      vy: -Math.random() * 14 - 4,
      w: Math.random() * 8 + 4,
      h: Math.random() * 6 + 2,
      color: colors[Math.floor(Math.random() * colors.length)],
      rotation: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 12,
      gravity: 0.3 + Math.random() * 0.15,
      opacity: 1,
    });
  }

  let frame;
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let alive = false;
    for (const p of particles) {
      p.x += p.vx;
      p.vy += p.gravity;
      p.y += p.vy;
      p.rotation += p.rotSpeed;
      p.opacity -= 0.006;
      if (p.opacity <= 0) continue;
      alive = true;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate((p.rotation * Math.PI) / 180);
      ctx.globalAlpha = Math.max(0, p.opacity);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();
    }
    if (alive) {
      frame = requestAnimationFrame(draw);
    } else {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  }
  frame = requestAnimationFrame(draw);
  // Auto-cleanup after 4 seconds
  setTimeout(() => {
    cancelAnimationFrame(frame);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }, 4000);
}


function generateShareText(myData, theirData, challengeData) {
  const myWords = new Set(myData.wordsFound || []);
  const theirWords = new Set(theirData.wordsFound || []);
  const allWords = [...(validWordsOnBoard || [])].sort();
  const totalFound = new Set([...myWords, ...theirWords]).size;
  const isWin = myData.score > theirData.score;
  const isTie = myData.score === theirData.score;
  const header = isWin ? 'Boggle PvP 👑' : isTie ? 'Boggle PvP 🤝' : 'Boggle PvP';

  // Build emoji grid — 10 per row
  const emojis = allWords.map(w => {
    const iFound = myWords.has(w);
    const theyFound = theirWords.has(w);
    if (iFound && theyFound) return '🟩';
    if (iFound) return '🟪';
    if (theyFound) return '🟨';
    return '⬛';
  });
  const rows = [];
  for (let i = 0; i < emojis.length; i += 10) {
    rows.push(emojis.slice(i, i + 10).join(''));
  }
  // Limit to 4 rows for readability
  const grid = rows.slice(0, 4).join('\n');

  return `${header}\n${myData.score} - ${theirData.score}\n${totalFound}/${allWords.length} words found\n\n${grid}`;
}

// ========== CINEMATIC COMPARISON ==========
function renderComparison(myData, theirData, challengeData) {
  // Clear previous animation timeouts
  comparisonTimeouts.forEach(id => clearTimeout(id));
  comparisonTimeouts = [];

  const leaderboard = document.getElementById('raceLeaderboard');
  const barMe = document.getElementById('raceBarMe');
  const barThem = document.getElementById('raceBarThem');
  const fillMe = document.getElementById('raceFillMe');
  const fillThem = document.getElementById('raceFillThem');
  const scoreMe = document.getElementById('raceScoreMe');
  const scoreThem = document.getElementById('raceScoreThem');
  const rankMe = document.getElementById('raceRankMe');
  const rankThem = document.getElementById('raceRankThem');
  const resultEl = document.getElementById('compResult');
  const shareBtn = document.getElementById('shareBtn');
  const container = document.getElementById('challengeAccordionContainer');

  // Reset tally board
  const tallyArea = document.getElementById('tallyBoardArea');
  tallyArea.classList.add('hidden');
  tallyArea.classList.remove('fade-out');
  clearTallyBoard();

  // Reset all states
  leaderboard.classList.remove('reveal');
  barMe.classList.remove('leader');
  barThem.classList.remove('leader');
  barMe.setAttribute('data-pos', '0');
  barThem.setAttribute('data-pos', '1');
  fillMe.style.width = '52px';
  fillThem.style.width = '52px';
  scoreMe.textContent = '0';
  scoreThem.textContent = '0';
  rankMe.textContent = '1';
  rankThem.textContent = '2';
  resultEl.classList.remove('reveal');
  resultEl.className = 'comparison-result';
  shareBtn.classList.remove('reveal', 'copied');
  shareBtn.style.display = 'none';
  container.style.display = 'none';
  container.innerHTML = '';

  const isWin = myData.score > theirData.score;
  const isLoss = myData.score < theirData.score;
  const isTie = myData.score === theirData.score;

  // Build word-by-word score sequences
  const myWords = myData.wordsFound || [];
  const theirWords = theirData.wordsFound || [];

  // Both zero — skip tally
  if (myWords.length === 0 && theirWords.length === 0) {
    comparisonTimeouts.push(setTimeout(() => {
      leaderboard.classList.add('reveal');
    }, 0));
    comparisonTimeouts.push(setTimeout(() => {
      resultEl.textContent = "It's a tie!";
      resultEl.className = 'comparison-result tie reveal';
    }, 600));
    comparisonTimeouts.push(setTimeout(() => {
      container.style.display = '';
      shareBtn.style.display = '';
      const myWordSet = new Set(myWords);
      const theirWordSet = new Set(theirWords);
      buildWordAccordion(container, validWordsOnBoard, myWordSet, theirWordSet, true);
      shareBtn.classList.add('reveal');
      wireShareBtn(shareBtn, myData, theirData, challengeData);
    }, 800));
    return;
  }

  // Build word sets for overlap detection
  const myWordSet = new Set(myWords);
  const theirWordSet = new Set(theirWords);

  // Build interleaved steps: alternate one word from me, one from them
  const steps = [];
  let runMe = 0, runThem = 0;
  const maxI = Math.max(myWords.length, theirWords.length);
  for (let i = 0; i < maxI; i++) {
    if (i < myWords.length) {
      const w = myWords[i];
      runMe += scoreWord(w);
      const foundBy = theirWordSet.has(w) ? 'both' : 'me';
      steps.push({ me: runMe, them: runThem, changed: 'me', word: w, foundBy });
    }
    if (i < theirWords.length) {
      const w = theirWords[i];
      runThem += scoreWord(w);
      const foundBy = myWordSet.has(w) ? 'both' : 'them';
      steps.push({ me: runMe, them: runThem, changed: 'them', word: w, foundBy });
    }
  }

  // Batch steps if there are too many — cap at ~30 steps for ~5-10s tally
  const MAX_STEPS = 30;
  let displaySteps = steps;
  if (steps.length > MAX_STEPS) {
    const batchSize = Math.ceil(steps.length / MAX_STEPS);
    displaySteps = [];
    for (let i = 0; i < steps.length; i += batchSize) {
      const end = Math.min(i + batchSize, steps.length) - 1;
      displaySteps.push(steps[end]);
    }
    // Always include final step
    if (displaySteps[displaySteps.length - 1] !== steps[steps.length - 1]) {
      displaySteps.push(steps[steps.length - 1]);
    }
  }

  const maxScore = Math.max(myData.score, theirData.score, 1);
  const stepInterval = Math.max(300, Math.min(500, 8000 / displaySteps.length));
  let lastLeader = null; // 'me', 'them', or null (tie)

  // Bar width: min 52px (just rank badge), max ~75% of track
  function barWidth(score) {
    if (score === 0) return '52px';
    const pct = Math.max(15, (score / maxScore) * 75);
    return pct + '%';
  }

  // Phase 0: Entrance — bars fade/slide in, initialize mini board
  comparisonTimeouts.push(setTimeout(() => {
    leaderboard.classList.add('reveal');
  }, 0));

  // Build initial tally board grid (no highlights) so it fades in with tiles visible
  comparisonTimeouts.push(setTimeout(() => {
    const tallyBoard = document.getElementById('tallyBoard');
    tallyBoard.innerHTML = '';
    tallyBoard.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
    const gaps = { 4: 6, 5: 5, 6: 4 };
    tallyBoard.style.gap = (gaps[GRID_SIZE] || 5) + 'px';
    board.forEach((letter) => {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.style.fontSize = '13px';
      tile.textContent = letter === 'Q' ? 'Qu' : letter;
      tallyBoard.appendChild(tile);
    });
    tallyArea.classList.remove('hidden');
  }, 200));

  // Phase 1: Tally — step through scores
  const tallyStart = 700;
  displaySteps.forEach((step, idx) => {
    comparisonTimeouts.push(setTimeout(() => {
      // Highlight board with word path
      if (step.word && allWordPaths[step.word]) {
        const highlightClass = step.foundBy === 'both' ? 'path-highlight-both'
          : step.foundBy === 'me' ? 'path-highlight-me' : 'path-highlight-them';
        const lineClass = step.foundBy === 'both' ? 'line-both'
          : step.foundBy === 'me' ? 'line-me' : 'line-them';
        renderTallyBoard(step.word, highlightClass, lineClass);
        const tallyLabel = document.getElementById('tallyWordLabel');
        tallyLabel.className = 'tally-word-label ' + (step.foundBy || step.changed);
      }

      // Burst animation on scoring bar(s)
      if (step.foundBy === 'both') {
        [fillMe, fillThem].forEach(bar => {
          bar.classList.remove('burst');
          void bar.offsetWidth;
          bar.classList.add('burst');
        });
      } else {
        const burstBar = step.changed === 'me' ? fillMe : fillThem;
        burstBar.classList.remove('burst');
        void burstBar.offsetWidth;
        burstBar.classList.add('burst');
      }

      // Update scores
      scoreMe.textContent = step.me;
      scoreThem.textContent = step.them;

      // Update bar widths
      fillMe.style.width = barWidth(step.me);
      fillThem.style.width = barWidth(step.them);

      // Bump animation on changed score
      const changedEl = step.changed === 'me' ? scoreMe : scoreThem;
      changedEl.classList.remove('bump');
      // Force reflow to restart animation
      void changedEl.offsetWidth;
      changedEl.classList.add('bump');

      // Determine leader
      let leader = null;
      if (step.me > step.them) leader = 'me';
      else if (step.them > step.me) leader = 'them';

      // Only swap positions on leader change (not ties — keep current positions)
      if (leader !== null && leader !== lastLeader) {
        lastLeader = leader;
        if (leader === 'me') {
          barMe.setAttribute('data-pos', '0');
          barThem.setAttribute('data-pos', '1');
          barMe.classList.add('leader');
          barThem.classList.remove('leader');
          rankMe.textContent = '1';
          rankThem.textContent = '2';
        } else {
          barThem.setAttribute('data-pos', '0');
          barMe.setAttribute('data-pos', '1');
          barThem.classList.add('leader');
          barMe.classList.remove('leader');
          rankThem.textContent = '1';
          rankMe.textContent = '2';
        }
      } else if (leader === null && lastLeader !== null) {
        // Tied — remove leader highlights but keep positions
        barMe.classList.remove('leader');
        barThem.classList.remove('leader');
        rankMe.textContent = '-';
        rankThem.textContent = '-';
        lastLeader = null;
      }
    }, tallyStart + idx * stepInterval));
  });

  const tallyEnd = tallyStart + displaySteps.length * stepInterval;

  // Force final scores to match Firestore (single source of truth)
  comparisonTimeouts.push(setTimeout(() => {
    scoreMe.textContent = myData.score;
    scoreThem.textContent = theirData.score;
    fillMe.style.width = barWidth(myData.score);
    fillThem.style.width = barWidth(theirData.score);
  }, tallyEnd));

  // Phase 1.5: Fade out tally board
  comparisonTimeouts.push(setTimeout(() => {
    tallyArea.classList.add('fade-out');
  }, tallyEnd + 100));
  comparisonTimeouts.push(setTimeout(() => {
    tallyArea.classList.add('hidden');
    tallyArea.classList.remove('fade-out');
    clearTallyBoard();
  }, tallyEnd + 400));

  // Phase 2: Result text slams in
  comparisonTimeouts.push(setTimeout(() => {
    if (isWin) {
      resultEl.textContent = 'You win!';
      resultEl.className = 'comparison-result win reveal';
    } else if (isLoss) {
      resultEl.textContent = 'You lose';
      resultEl.className = 'comparison-result lose reveal';
    } else {
      resultEl.textContent = "It's a tie!";
      resultEl.className = 'comparison-result tie reveal';
    }
  }, tallyEnd + 600));

  // Phase 3: Confetti on win
  comparisonTimeouts.push(setTimeout(() => {
    if (isWin) launchConfetti();
  }, tallyEnd + 800));

  // Phase 4: Word accordion + share button (unhide then animate)
  comparisonTimeouts.push(setTimeout(() => {
    container.style.display = '';
    shareBtn.style.display = '';
    buildWordAccordion(container, validWordsOnBoard, myWordSet, theirWordSet, true);
    shareBtn.classList.add('reveal');
    wireShareBtn(shareBtn, myData, theirData, challengeData);
  }, tallyEnd + 1000));
}

function wireShareBtn(shareBtn, myData, theirData, challengeData) {
  shareBtn.onclick = () => {
    const text = generateShareText(myData, theirData, challengeData);
    navigator.clipboard.writeText(text).then(() => {
      shareBtn.textContent = 'Copied!';
      shareBtn.classList.add('copied');
      setTimeout(() => {
        shareBtn.textContent = 'Share Results';
        shareBtn.classList.remove('copied');
      }, 2000);
    }).catch(() => {
      shareBtn.textContent = 'Share Results';
    });
  };
}

// ========== URL HANDLING ==========
function checkUrlForChallenge() {
  const params = new URLSearchParams(window.location.search);
  const challengeId = params.get('c');
  if (challengeId) {
    joinChallenge(challengeId);
  }
}

// ========== TALLY BOARD HELPERS ==========
function renderTallyBoard(word, highlightClass, lineClass) {
  const tallyBoard = document.getElementById('tallyBoard');
  const tallySvg = document.getElementById('tallyPathSvg');
  const tallyLabel = document.getElementById('tallyWordLabel');
  const boardWrap = document.getElementById('tallyBoardWrap');

  tallyBoard.innerHTML = '';
  tallySvg.querySelectorAll('line').forEach(l => l.remove());
  tallyBoard.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  const gaps = { 4: 6, 5: 5, 6: 4 };
  tallyBoard.style.gap = (gaps[GRID_SIZE] || 5) + 'px';

  const path = allWordPaths[word] || [];
  const pathSet = new Set(path);

  board.forEach((letter, i) => {
    const tile = document.createElement('div');
    tile.className = 'tile' + (pathSet.has(i) ? ' ' + highlightClass : '');
    tile.style.fontSize = '13px';
    tile.textContent = letter === 'Q' ? 'Qu' : letter;
    tallyBoard.appendChild(tile);
  });

  // Draw path lines
  requestAnimationFrame(() => {
    const wrapRect = boardWrap.getBoundingClientRect();
    for (let i = 1; i < path.length; i++) {
      const fromTile = tallyBoard.children[path[i - 1]];
      const toTile = tallyBoard.children[path[i]];
      if (!fromTile || !toTile) continue;
      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const x1 = ((fromRect.left + fromRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y1 = ((fromRect.top + fromRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const x2 = ((toRect.left + toRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y2 = ((toRect.top + toRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.classList.add(lineClass);
      tallySvg.appendChild(line);
    }
  });

  tallyLabel.textContent = word.toUpperCase();
}

function clearTallyBoard() {
  const tallyBoard = document.getElementById('tallyBoard');
  const tallySvg = document.getElementById('tallyPathSvg');
  const tallyLabel = document.getElementById('tallyWordLabel');
  tallyBoard.innerHTML = '';
  // Remove lines but keep <defs> for gradients
  tallySvg.querySelectorAll('line').forEach(l => l.remove());
  tallyLabel.textContent = '';
  tallyLabel.className = 'tally-word-label';
}

// ========== WORD PATH MODAL ==========
function showWordPath(word) {
  const modal = document.getElementById('wordModal');
  const modalBoard = document.getElementById('modalBoard');
  const modalSvg = document.getElementById('modalPathSvg');
  const modalTitle = document.getElementById('wordModalTitle');
  const boardWrap = document.querySelector('.word-modal-board-wrap');

  modalTitle.textContent = word.toUpperCase();

  // Render mini board
  modalBoard.innerHTML = '';
  modalBoard.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  const gaps = { 4: 10, 5: 8, 6: 6 };
  const fonts = { 4: 18, 5: 16, 6: 13 };
  modalBoard.style.gap = (gaps[GRID_SIZE] || 8) + 'px';

  const path = allWordPaths[word] || [];
  const pathSet = new Set(path);

  board.forEach((letter, i) => {
    const tile = document.createElement('div');
    tile.className = 'tile' + (pathSet.has(i) ? ' path-highlight' : '');
    tile.style.fontSize = (fonts[GRID_SIZE] || 14) + 'px';
    tile.textContent = letter === 'Q' ? 'Qu' : letter;
    modalBoard.appendChild(tile);
  });

  // Draw path lines
  modalSvg.innerHTML = '';
  requestAnimationFrame(() => {
    const wrapRect = boardWrap.getBoundingClientRect();
    for (let i = 1; i < path.length; i++) {
      const fromTile = modalBoard.children[path[i - 1]];
      const toTile = modalBoard.children[path[i]];
      if (!fromTile || !toTile) continue;
      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const x1 = ((fromRect.left + fromRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y1 = ((fromRect.top + fromRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const x2 = ((toRect.left + toRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y2 = ((toRect.top + toRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      modalSvg.appendChild(line);
    }
  });

  modal.classList.remove('hidden');
}

document.getElementById('wordModalBackdrop').addEventListener('click', () => {
  document.getElementById('wordModal').classList.add('hidden');
});
document.getElementById('wordModalClose').addEventListener('click', () => {
  document.getElementById('wordModal').classList.add('hidden');
});

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('replayBtn').addEventListener('click', () => {
  startGame();
});

// Play again trigger opens new game modal
document.getElementById('playAgainTrigger').addEventListener('click', () => {
  document.getElementById('newGameModal').classList.remove('hidden');
});
document.getElementById('newGameModalBackdrop').addEventListener('click', () => {
  document.getElementById('newGameModal').classList.add('hidden');
});

// Settings toggle behavior
document.querySelectorAll('.setting-options').forEach(group => {
  group.addEventListener('click', e => {
    const btn = e.target.closest('button');
    if (!btn) return;
    group.querySelectorAll('button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

musicToggle.addEventListener('click', () => {
  if (musicPlaying) {
    stopMusic();
    musicToggle.textContent = '♪';
    musicToggle.style.opacity = '0.4';
  } else if (gameActive) {
    initAudio();
    startMusic();
    musicToggle.textContent = '♪';
    musicToggle.style.opacity = '1';
  }
});

// ========== CHALLENGE EVENT LISTENERS ==========
document.getElementById('challengeBtn').addEventListener('click', async () => {
  document.getElementById('challengeBtn').textContent = 'Creating...';
  try {
    await createChallenge();
  } catch (err) {
    console.error('Create challenge error:', err);
    showChallengeError('Failed to create challenge. Please try again.');
  }
  document.getElementById('challengeBtn').textContent = 'Challenge a Friend';
});

document.getElementById('copyLinkBtn').addEventListener('click', () => {
  const input = document.getElementById('challengeLink');
  navigator.clipboard.writeText(input.value).then(() => {
    document.getElementById('copyLinkBtn').textContent = 'Copied!';
    setTimeout(() => {
      document.getElementById('copyLinkBtn').textContent = 'Copy';
    }, 2000);
  });
});

document.getElementById('playOwnChallengeBtn').addEventListener('click', () => {
  startGame();
});

document.getElementById('lobbyStartBtn').addEventListener('click', () => {
  startGame();
});

document.getElementById('challengePlayAgain').addEventListener('click', () => {
  // Clean up challenge state
  challengeMode = false;
  currentChallengeId = null;
  currentChallengeData = null;
  if (challengeUnsubscribe) {
    challengeUnsubscribe();
    challengeUnsubscribe = null;
  }
  // Clear URL params
  history.replaceState(null, '', location.pathname);
  // Hide challenge screens, show start
  document.getElementById('challengeEndScreen').classList.add('hidden');
  startScreen.classList.remove('hidden');
});

document.getElementById('challengeErrorHomeBtn').addEventListener('click', () => {
  challengeMode = false;
  currentChallengeId = null;
  currentChallengeData = null;
  history.replaceState(null, '', location.pathname);
  document.getElementById('challengeErrorScreen').classList.add('hidden');
  startScreen.classList.remove('hidden');
});

// ========== DEV BACKDOOR ==========
// Usage: call window.__testComparison() from browser console
// Options: __testComparison({ myWordCount, theirWordCount, scenario })
// scenario: 'win' (default), 'lose', 'tie', 'blowout', 'close', 'empty'
window.__testComparison = async function(opts = {}) {
  const scenario = opts.scenario || 'win';

  // Ensure dictionary is loaded and board is solved
  await loadDictionary();
  GRID_SIZE = 5;
  MIN_WORD_LENGTH = 4;
  NEIGHBOR_MAP = buildNeighborMap();
  board = generateBoard();
  const solveResult = findAllWords(board);
  validWordsOnBoard = solveResult.words;
  allWordPaths = solveResult.paths;

  const allWords = [...validWordsOnBoard].sort(() => Math.random() - 0.5);

  let myCount, theirCount;
  switch (scenario) {
    case 'lose':
      myCount = opts.myWordCount || Math.min(3, allWords.length);
      theirCount = opts.theirWordCount || Math.min(10, allWords.length);
      break;
    case 'tie':
      myCount = opts.myWordCount || Math.min(6, allWords.length);
      theirCount = myCount;
      break;
    case 'blowout':
      myCount = opts.myWordCount || Math.min(15, allWords.length);
      theirCount = opts.theirWordCount || Math.min(2, allWords.length);
      break;
    case 'close':
      myCount = opts.myWordCount || Math.min(8, allWords.length);
      theirCount = opts.theirWordCount || Math.min(7, allWords.length);
      break;
    case 'empty':
      myCount = 0;
      theirCount = 0;
      break;
    default: // 'win'
      myCount = opts.myWordCount || Math.min(8, allWords.length);
      theirCount = opts.theirWordCount || Math.min(4, allWords.length);
  }

  // For tie scenario, give both players the exact same words
  let myWords, theirWords;
  if (scenario === 'tie') {
    myWords = allWords.slice(0, myCount);
    theirWords = [...myWords];
  } else {
    // Shuffle separately so words don't fully overlap
    const shuffled2 = [...allWords].sort(() => Math.random() - 0.5);
    myWords = allWords.slice(0, myCount);
    theirWords = shuffled2.slice(0, theirCount);
  }

  const calcScore = words => words.reduce((s, w) => s + scoreWord(w), 0);

  const myData = {
    score: calcScore(myWords),
    wordCount: myWords.length,
    wordsFound: myWords,
  };
  const theirData = {
    score: calcScore(theirWords),
    wordCount: theirWords.length,
    wordsFound: theirWords,
  };
  const challengeData = {
    totalValidWords: validWordsOnBoard.size,
    board,
    gridSize: GRID_SIZE,
    minWordLength: MIN_WORD_LENGTH,
  };

  // Hide all overlays, show challenge end screen with comparison
  document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
  const endScreen = document.getElementById('challengeEndScreen');
  endScreen.classList.remove('hidden');
  document.getElementById('challengeWaiting').classList.add('hidden');
  document.getElementById('challengeComparison').classList.remove('hidden');

  renderComparison(myData, theirData, challengeData);

  console.log(`[dev] Racing leaderboard test: scenario="${scenario}"`,
    `\n  You: ${myData.score} pts (${myWords.length} words)`,
    `\n  Them: ${theirData.score} pts (${theirWords.length} words)`,
    `\n  Board has ${validWordsOnBoard.size} valid words`);
};

// Check URL for challenge on page load
checkUrlForChallenge();
</script>
<canvas id="confettiCanvas"></canvas>
</body>
</html>
