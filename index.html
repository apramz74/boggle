<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Boggle</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --bg-surface: #222244;
    --tile-bg: #2a2a4a;
    --tile-selected: #3a2e78;
    --tile-border: #3a3a5a;
    --text-primary: #eee8f5;
    --text-dim: #8888aa;
    --accent-green: #5ce0a0;
    --accent-red: #ff6b7a;
    --accent-gold: #f0c060;
    --radius: 14px;
  }

  html, body {
    height: 100%;
    overflow: hidden;
    background: var(--bg);
    color: var(--text-primary);
    font-family: 'DM Sans', sans-serif;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100dvh;
    padding: 20px;
    background: 
      radial-gradient(ellipse at 30% 20%, rgba(90, 60, 160, 0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 70% 80%, rgba(60, 100, 160, 0.1) 0%, transparent 60%),
      var(--bg);
  }

  /* --- TOP BAR --- */
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 380px;
    margin-bottom: 28px;
    padding: 0 4px;
  }

  .score-display {
    font-family: 'Space Mono', monospace;
    font-size: 28px;
    font-weight: 700;
    color: var(--text-primary);
    letter-spacing: -1px;
  }

  .timer-display {
    font-family: 'Space Mono', monospace;
    font-size: 22px;
    font-weight: 700;
    color: var(--text-dim);
    transition: color 0.3s;
  }
  .timer-display.urgent {
    color: var(--accent-red);
  }

  /* --- CURRENT WORD --- */
  .word-display-area {
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
    width: 100%;
    max-width: 380px;
  }

  .current-word {
    font-family: 'Space Mono', monospace;
    font-size: 26px;
    font-weight: 700;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: #ffffff;
    text-shadow: 0 0 12px rgba(140, 120, 220, 0.5);
    transition: opacity 0.1s;
    min-height: 32px;
  }

  /* --- FEEDBACK TOAST --- */
  .feedback-toast {
    position: fixed;
    left: 50%;
    transform: translateX(-50%) translateY(-4px) scale(0.9);
    font-family: 'Space Mono', monospace;
    font-size: 16px;
    font-weight: 700;
    padding: 8px 22px;
    border-radius: 10px;
    opacity: 0;
    pointer-events: none;
    z-index: 100;
    transition: none;
    /* Positioned via JS relative to board top */
    top: 0;
  }
  .feedback-toast.valid {
    background: rgba(92, 224, 160, 0.15);
    color: var(--accent-green);
    border: 1.5px solid rgba(92, 224, 160, 0.3);
  }
  .feedback-toast.invalid {
    background: rgba(255, 107, 122, 0.12);
    color: var(--accent-red);
    border: 1.5px solid rgba(255, 107, 122, 0.25);
  }
  .feedback-toast.duplicate {
    background: rgba(136, 136, 170, 0.12);
    color: var(--text-dim);
    border: 1.5px solid rgba(136, 136, 170, 0.25);
  }
  .feedback-toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0) scale(1);
    transition: opacity 0.08s ease-out, transform 0.08s ease-out;
  }
  .feedback-toast.hide {
    opacity: 0;
    transform: translateX(-50%) translateY(-4px) scale(0.95);
    transition: opacity 0.25s ease-in, transform 0.25s ease-in;
  }

  /* --- BOARD --- */
  .board-container {
    position: relative;
    width: 100%;
    max-width: 380px;
    aspect-ratio: 1;
  }

  .board {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
    width: 100%;
    height: 100%;
  }

  .tile {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--tile-bg);
    border: 1.5px solid var(--tile-border);
    border-radius: var(--radius);
    font-family: 'Space Mono', monospace;
    font-size: 22px;
    font-weight: 700;
    color: var(--text-primary);
    cursor: pointer;
    transform: scale(1);
    transition: background 0.06s, border-color 0.06s, box-shadow 0.06s;
    -webkit-tap-highlight-color: transparent;
    will-change: transform;
  }
  .tile.selected {
    background: var(--tile-selected);
    border-color: rgba(120, 100, 200, 0.6);
    box-shadow: 0 0 16px rgba(120, 100, 200, 0.3);
    z-index: 2;
  }
  .tile.pop {
    animation: tilePop 0.18s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }
  .tile.unpop {
    animation: tileUnpop 0.12s ease-out forwards;
  }
  @keyframes tilePop {
    0% { transform: scale(1); }
    50% { transform: scale(1.14); }
    100% { transform: scale(1.06); }
  }
  @keyframes tileUnpop {
    0% { transform: scale(1.06); }
    100% { transform: scale(1); }
  }

  /* Score bump */
  .score-display.bump {
    animation: scoreBump 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  @keyframes scoreBump {
    0% { transform: scale(1); }
    40% { transform: scale(1.25); }
    100% { transform: scale(1); }
  }

  /* Tile result states */
  .tile.result-valid {
    background: var(--accent-green);
    border-color: rgba(92, 224, 160, 0.6);
    box-shadow: 0 0 18px rgba(92, 224, 160, 0.3);
    color: #1a2a1a;
    animation: tileShakeValid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-invalid {
    background: var(--accent-red);
    border-color: rgba(255, 107, 122, 0.6);
    box-shadow: 0 0 18px rgba(255, 107, 122, 0.25);
    color: #2a1a1a;
    animation: tileShakeInvalid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-duplicate {
    background: #555577;
    border-color: rgba(136, 136, 170, 0.5);
    box-shadow: 0 0 12px rgba(136, 136, 170, 0.2);
    animation: tileShakeInvalid 0.35s ease-out;
    z-index: 2;
  }
  .tile.result-fade {
    transition: background 0.3s ease-out, border-color 0.3s ease-out, box-shadow 0.3s ease-out, color 0.3s ease-out;
  }

  @keyframes tileShakeValid {
    0% { transform: scale(1.06); }
    25% { transform: scale(1.18); }
    50% { transform: scale(1.02); }
    75% { transform: scale(1.1); }
    100% { transform: scale(1.06); }
  }
  @keyframes tileShakeInvalid {
    0% { transform: scale(1.06); }
    15% { transform: scale(1.06) translateX(-4px); }
    30% { transform: scale(1.06) translateX(4px); }
    45% { transform: scale(1.06) translateX(-3px); }
    60% { transform: scale(1.06) translateX(2px); }
    75% { transform: scale(1.06) translateX(-1px); }
    100% { transform: scale(1.06); }
  }

  /* Selection path line overlay */
  .path-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
  }
  .path-svg line {
    stroke: rgba(140, 120, 220, 0.35);
    stroke-width: 3;
    stroke-linecap: round;
  }

  /* --- START / END SCREENS --- */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(26, 26, 46, 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    overflow-y: auto;
    padding: 24px 16px;
  }
  .overlay.hidden {
    display: none;
  }

  .overlay h1 {
    font-family: 'Space Mono', monospace;
    font-size: 36px;
    font-weight: 700;
    margin-bottom: 8px;
    letter-spacing: -1px;
  }

  .overlay .subtitle {
    color: var(--text-dim);
    font-size: 15px;
    margin-bottom: 40px;
  }

  .play-btn {
    font-family: 'DM Sans', sans-serif;
    font-size: 18px;
    font-weight: 700;
    padding: 16px 48px;
    border: none;
    border-radius: 50px;
    background: linear-gradient(135deg, #6c5ce7, #a78bfa);
    color: white;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
    letter-spacing: 0.5px;
  }
  .play-btn:hover {
    transform: scale(1.04);
    box-shadow: 0 8px 30px rgba(108, 92, 231, 0.35);
  }
  .play-btn:active {
    transform: scale(0.98);
  }

  .end-header {
    text-align: center;
    margin-bottom: 16px;
    flex-shrink: 0;
  }

  .end-score {
    font-family: 'Space Mono', monospace;
    font-size: 48px;
    font-weight: 700;
    color: var(--accent-gold);
    margin-bottom: 2px;
  }

  .end-ratio {
    color: var(--text-dim);
    font-size: 14px;
    font-family: 'DM Sans', sans-serif;
  }

  /* Accordion */
  .accordion-container {
    width: 100%;
    max-height: 65vh;
    overflow-y: auto;
    margin-bottom: 16px;
    flex: 1 1 auto;
    padding: 0 16px;
  }
  .accordion-section {
    margin-bottom: 6px;
  }
  .accordion-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.12s;
  }
  .accordion-header:hover {
    background: rgba(255,255,255,0.07);
  }
  .accordion-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .accordion-header-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-primary);
  }
  .accordion-header-count {
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    color: var(--text-dim);
  }
  .accordion-chevron {
    width: 16px;
    height: 16px;
    position: relative;
    flex-shrink: 0;
  }
  .accordion-chevron::before,
  .accordion-chevron::after {
    content: '';
    position: absolute;
    background: var(--text-dim);
    border-radius: 1px;
    transition: transform 0.2s ease;
  }
  .accordion-chevron::before {
    width: 8px;
    height: 1.5px;
    top: 5.5px;
    left: 4px;
    transform: rotate(45deg);
  }
  .accordion-chevron::after {
    width: 8px;
    height: 1.5px;
    top: 9.5px;
    left: 4px;
    transform: rotate(-45deg);
  }
  .accordion-section.open .accordion-chevron::before {
    transform: rotate(-45deg);
  }
  .accordion-section.open .accordion-chevron::after {
    transform: rotate(45deg);
  }
  .accordion-section.open .accordion-header {
    border-radius: 10px 10px 0 0;
    border-bottom-color: transparent;
  }
  .accordion-body {
    display: none;
    padding: 6px;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.06);
    border-top: none;
    border-radius: 0 0 10px 10px;
  }
  .accordion-section.open .accordion-body {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
    gap: 5px;
  }
  .accordion-word {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    padding: 6px 2px;
    border-radius: 6px;
    cursor: default;
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .accordion-word.found {
    background: rgba(92, 224, 160, 0.12);
    color: var(--accent-green);
  }
  .accordion-word.missed {
    background: rgba(255,255,255,0.05);
    color: var(--text-dim);
    cursor: pointer;
    transition: background 0.1s;
  }
  .accordion-word.missed:hover {
    background: rgba(255,255,255,0.1);
  }

  /* Play again trigger */
  .play-again-trigger {
    font-family: 'DM Sans', sans-serif;
    font-size: 15px;
    font-weight: 600;
    color: var(--text-primary);
    background: rgba(140, 120, 220, 0.2);
    border: 1.5px solid rgba(140, 120, 220, 0.3);
    border-radius: 12px;
    padding: 12px 32px;
    cursor: pointer;
    flex-shrink: 0;
    transition: background 0.15s;
    -webkit-tap-highlight-color: transparent;
  }
  .play-again-trigger:hover {
    background: rgba(140, 120, 220, 0.3);
  }

  /* New game modal */
  .new-game-modal {
    position: fixed;
    inset: 0;
    z-index: 400;
    display: flex;
    align-items: flex-end;
    justify-content: center;
  }
  .new-game-modal.hidden { display: none; }
  .new-game-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(10, 10, 20, 0.7);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }
  .new-game-modal-content {
    position: relative;
    z-index: 1;
    background: #1e1e36;
    border-radius: 20px 20px 0 0;
    padding: 28px 24px 36px;
    width: 100%;
    max-width: 420px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }
  .new-game-modal-title {
    font-family: 'DM Sans', sans-serif;
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
  }

  /* Word path modal */
  .word-modal {
    position: fixed;
    inset: 0;
    z-index: 500;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .word-modal.hidden { display: none; }
  .word-modal-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(10, 10, 20, 0.85);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
  .word-modal-content {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    z-index: 1;
    padding: 28px 24px;
  }
  .word-modal-title {
    font-family: 'Space Mono', monospace;
    font-size: 24px;
    font-weight: 700;
    letter-spacing: 4px;
    color: #ffffff;
    text-shadow: 0 0 12px rgba(140, 120, 220, 0.5);
  }
  .word-modal-board-wrap {
    position: relative;
    width: 280px;
    height: 280px;
  }
  .word-modal-board-wrap .board {
    width: 100%;
    height: 100%;
  }
  .word-modal-board-wrap .tile {
    font-size: 16px;
  }
  .word-modal-board-wrap .tile.path-highlight {
    background: var(--tile-selected);
    border-color: rgba(120, 100, 200, 0.6);
    box-shadow: 0 0 14px rgba(120, 100, 200, 0.3);
    color: #fff;
    z-index: 2;
  }
  .word-modal-board-wrap .path-svg line {
    stroke: rgba(140, 120, 220, 0.4);
    stroke-width: 2.5;
    stroke-linecap: round;
  }
  .word-modal-close {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(255,255,255,0.08);
    border-radius: 50%;
    color: var(--text-dim);
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s;
  }
  .word-modal-close:hover { background: rgba(255,255,255,0.15); }

  /* Settings */
  .settings {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-bottom: 32px;
    width: 100%;
    max-width: 360px;
  }
  .setting-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .setting-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    color: var(--text-dim);
    flex-shrink: 0;
    width: 80px;
  }
  .setting-options {
    display: flex;
    gap: 6px;
  }
  .setting-options button {
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    font-weight: 700;
    padding: 8px 14px;
    border: 1.5px solid var(--tile-border);
    border-radius: 10px;
    background: var(--tile-bg);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.12s;
    -webkit-tap-highlight-color: transparent;
  }
  .setting-options button.active {
    background: var(--tile-selected);
    border-color: rgba(120, 100, 200, 0.6);
    color: var(--text-primary);
    box-shadow: 0 0 12px rgba(120, 100, 200, 0.2);
  }
  .setting-options button:hover:not(.active) {
    border-color: rgba(120, 100, 200, 0.3);
    color: var(--text-primary);
  }

  /* Music toggle */
  .music-toggle {
    position: fixed;
    top: 16px;
    right: 16px;
    width: 36px;
    height: 36px;
    border: none;
    background: rgba(255,255,255,0.06);
    border-radius: 50%;
    color: var(--text-dim);
    font-size: 16px;
    cursor: pointer;
    z-index: 300;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
  }
  .music-toggle:hover { background: rgba(255,255,255,0.1); }

  /* --- CHALLENGE MODE --- */
  .challenge-btn {
    font-family: 'DM Sans', sans-serif;
    font-size: 15px;
    font-weight: 600;
    padding: 12px 32px;
    margin-top: 12px;
    border: 1.5px solid rgba(140, 120, 220, 0.3);
    border-radius: 50px;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.3px;
  }
  .challenge-btn:hover {
    border-color: rgba(140, 120, 220, 0.6);
    color: var(--text-primary);
    background: rgba(140, 120, 220, 0.1);
  }

  .challenge-link-box {
    display: flex;
    gap: 8px;
    width: 100%;
    max-width: 360px;
    margin-bottom: 28px;
  }
  .challenge-link-box input {
    flex: 1;
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    padding: 12px 14px;
    border: 1.5px solid var(--tile-border);
    border-radius: 10px;
    background: var(--tile-bg);
    color: var(--text-primary);
    outline: none;
  }
  .copy-btn {
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    padding: 12px 20px;
    border: none;
    border-radius: 10px;
    background: rgba(92, 224, 160, 0.15);
    color: var(--accent-green);
    cursor: pointer;
    transition: background 0.15s;
    white-space: nowrap;
  }
  .copy-btn:hover { background: rgba(92, 224, 160, 0.25); }

  .lobby-settings {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 32px;
    width: 100%;
    max-width: 280px;
  }
  .lobby-setting {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
  }
  .lobby-label {
    font-size: 14px;
    color: var(--text-dim);
  }
  .lobby-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-primary);
  }

  .waiting-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    margin: 24px 0;
    color: var(--text-dim);
    font-size: 15px;
  }
  .waiting-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid rgba(140, 120, 220, 0.2);
    border-top-color: rgba(140, 120, 220, 0.8);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .challenge-comparison-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    flex: 1;
    min-height: 0;
  }
  .challenge-comparison-wrap.hidden {
    display: none !important;
  }

  .comparison-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    margin-bottom: 8px;
    width: 100%;
    max-width: 360px;
  }
  .comparison-player {
    text-align: center;
    flex: 1;
  }
  .comparison-label {
    font-size: 13px;
    color: var(--text-dim);
    margin-bottom: 4px;
  }
  .comparison-score {
    font-family: 'Space Mono', monospace;
    font-size: 36px;
    font-weight: 700;
    color: var(--accent-gold);
  }
  .comparison-words {
    font-size: 13px;
    color: var(--text-dim);
    font-family: 'DM Sans', sans-serif;
  }
  .comparison-vs {
    font-family: 'Space Mono', monospace;
    font-size: 18px;
    color: var(--text-dim);
    padding-top: 16px;
  }
  .comparison-result {
    text-align: center;
    font-family: 'DM Sans', sans-serif;
    font-size: 18px;
    font-weight: 700;
    margin-bottom: 16px;
  }
  .comparison-result.win { color: var(--accent-green); }
  .comparison-result.lose { color: var(--accent-red); }
  .comparison-result.tie { color: var(--accent-gold); }

  /* Word comparison chip colors */
  .accordion-word.both-found {
    background: rgba(92, 224, 160, 0.12);
    color: var(--accent-green);
  }
  .accordion-word.only-me {
    background: rgba(108, 92, 231, 0.15);
    color: #a78bfa;
  }
  .accordion-word.only-them {
    background: rgba(240, 192, 96, 0.12);
    color: var(--accent-gold);
  }
  .accordion-word.neither {
    background: rgba(255,255,255,0.05);
    color: var(--text-dim);
    cursor: pointer;
  }
  .accordion-word.neither:hover {
    background: rgba(255,255,255,0.1);
  }

  .hidden { display: none !important; }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
</style>
</head>
<body>

<button class="music-toggle" id="musicToggle">♪</button>

<!-- START SCREEN -->
<div class="overlay" id="startScreen">
  <h1>Boggle</h1>
  <p class="subtitle">swipe to find words</p>
  <div class="settings">
    <div class="setting-row">
      <span class="setting-label">Grid</span>
      <div class="setting-options" id="gridOptions">
        <button data-val="4">4×4</button>
        <button data-val="5" class="active">5×5</button>
        <button data-val="6">6×6</button>
      </div>
    </div>
    <div class="setting-row">
      <span class="setting-label">Min letters</span>
      <div class="setting-options" id="minWordOptions">
        <button data-val="3">3</button>
        <button data-val="4" class="active">4</button>
        <button data-val="5">5</button>
      </div>
    </div>
    <div class="setting-row">
      <span class="setting-label">Time</span>
      <div class="setting-options" id="timeOptions">
        <button data-val="30" class="active">0:30</button>
        <button data-val="60">1:00</button>
        <button data-val="90">1:30</button>
        <button data-val="120">2:00</button>
      </div>
    </div>
  </div>
  <button class="play-btn" id="startBtn">Play</button>
  <button class="challenge-btn" id="challengeBtn">Challenge a Friend</button>
</div>

<!-- CHALLENGE CREATED SCREEN -->
<div class="overlay hidden" id="challengeCreatedScreen">
  <h1>Challenge Ready</h1>
  <p class="subtitle">Share this link with a friend</p>
  <div class="challenge-link-box">
    <input type="text" id="challengeLink" readonly>
    <button class="copy-btn" id="copyLinkBtn">Copy</button>
  </div>
  <button class="play-btn" id="playOwnChallengeBtn">Play Now</button>
</div>

<!-- CHALLENGE LOBBY SCREEN -->
<div class="overlay hidden" id="challengeLobbyScreen">
  <h1>Challenge</h1>
  <p class="subtitle">You've been challenged!</p>
  <div class="lobby-settings">
    <div class="lobby-setting"><span class="lobby-label">Grid</span><span class="lobby-value" id="lobbyGrid">5×5</span></div>
    <div class="lobby-setting"><span class="lobby-label">Min letters</span><span class="lobby-value" id="lobbyMinWord">4</span></div>
    <div class="lobby-setting"><span class="lobby-label">Time</span><span class="lobby-value" id="lobbyTime">0:30</span></div>
  </div>
  <button class="play-btn" id="lobbyStartBtn">Start</button>
</div>

<!-- CHALLENGE END SCREEN -->
<div class="overlay hidden" id="challengeEndScreen">
  <!-- Waiting state -->
  <div id="challengeWaiting">
    <div class="end-header">
      <h1>Nice!</h1>
      <div class="end-score" id="challengeMyScore">0</div>
      <div class="end-ratio" id="challengeMyRatio">0/0 words</div>
    </div>
    <div class="waiting-box">
      <div class="waiting-spinner"></div>
      <p>Waiting for opponent...</p>
    </div>
  </div>
  <!-- Comparison state -->
  <div id="challengeComparison" class="hidden challenge-comparison-wrap">
    <div class="comparison-header">
      <div class="comparison-player">
        <div class="comparison-label">You</div>
        <div class="comparison-score" id="compMyScore">0</div>
        <div class="comparison-words" id="compMyWords">0 words</div>
      </div>
      <div class="comparison-vs">vs</div>
      <div class="comparison-player">
        <div class="comparison-label">Opponent</div>
        <div class="comparison-score" id="compTheirScore">0</div>
        <div class="comparison-words" id="compTheirWords">0 words</div>
      </div>
    </div>
    <div class="comparison-result" id="compResult"></div>
    <div class="accordion-container" id="challengeAccordionContainer"></div>
  </div>
  <button class="play-again-trigger" id="challengePlayAgain">Play again</button>
</div>

<!-- CHALLENGE ERROR SCREEN -->
<div class="overlay hidden" id="challengeErrorScreen">
  <h1>Oops</h1>
  <p class="subtitle" id="challengeErrorMsg">Challenge not found</p>
  <button class="play-btn" id="challengeErrorHomeBtn">Back to Home</button>
</div>

<!-- END SCREEN -->
<div class="overlay hidden" id="endScreen">
  <div class="end-header">
    <h1>Time's up</h1>
    <div class="end-score" id="endScore">0</div>
    <div class="end-ratio" id="endRatio">0/0 words</div>
  </div>
  <div class="accordion-container" id="accordionContainer"></div>
  <button class="play-again-trigger" id="playAgainTrigger">Play again</button>
</div>

<!-- NEW GAME MODAL -->
<div class="new-game-modal hidden" id="newGameModal">
  <div class="new-game-modal-backdrop" id="newGameModalBackdrop"></div>
  <div class="new-game-modal-content">
    <div class="new-game-modal-title">New game</div>
    <div class="settings">
      <div class="setting-row">
        <span class="setting-label">Grid</span>
        <div class="setting-options" id="gridOptions2">
          <button data-val="4">4×4</button>
          <button data-val="5" class="active">5×5</button>
          <button data-val="6">6×6</button>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Min letters</span>
        <div class="setting-options" id="minWordOptions2">
          <button data-val="3">3</button>
          <button data-val="4" class="active">4</button>
          <button data-val="5">5</button>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Time</span>
        <div class="setting-options" id="timeOptions2">
          <button data-val="30" class="active">0:30</button>
          <button data-val="60">1:00</button>
          <button data-val="90">1:30</button>
          <button data-val="120">2:00</button>
        </div>
      </div>
    </div>
    <button class="play-btn" id="replayBtn">Play</button>
  </div>
</div>

<!-- WORD PATH MODAL -->
<div class="word-modal hidden" id="wordModal">
  <div class="word-modal-backdrop" id="wordModalBackdrop"></div>
  <div class="word-modal-content">
    <div class="word-modal-title" id="wordModalTitle">WORD</div>
    <div class="word-modal-board-wrap">
      <svg class="path-svg" id="modalPathSvg"></svg>
      <div class="board" id="modalBoard"></div>
    </div>
    <button class="word-modal-close" id="wordModalClose">✕</button>
  </div>
</div>

<!-- GAME UI -->
<div class="top-bar" id="gameUI" style="visibility: hidden;">
  <div class="score-display" id="score">0</div>
  <div class="timer-display" id="timer">0:30</div>
</div>

<div class="word-display-area" id="wordArea" style="visibility: hidden;">
  <div class="current-word" id="currentWord"></div>
</div>

<div class="board-container" id="boardContainer" style="visibility: hidden;">
  <svg class="path-svg" id="pathSvg"></svg>
  <div class="board" id="board"></div>
</div>

<div class="feedback-toast" id="toast"></div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>

<!-- Dictionary (extracted for maintainability) -->
<script src="dictionary.js"></script>

<script>
// ========== FIREBASE ==========
const firebaseConfig = {
  apiKey: "***REMOVED***",
  authDomain: "boggle-351dc.firebaseapp.com",
  projectId: "boggle-351dc",
  storageBucket: "boggle-351dc.firebasestorage.app",
  messagingSenderId: "864208454720",
  appId: "1:864208454720:web:be8d95204b468c4b090ba5",
  measurementId: "G-VE9BT1CSMZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

function getPlayerId() {
  let id = localStorage.getItem('boggle_player_id');
  if (!id) {
    id = crypto.randomUUID();
    localStorage.setItem('boggle_player_id', id);
  }
  return id;
}
const MY_PLAYER_ID = getPlayerId();

// ========== CHALLENGE STATE ==========
let challengeMode = false;
let currentChallengeId = null;
let currentChallengeData = null;
let challengeUnsubscribe = null; // onSnapshot listener cleanup

// ========== DICTIONARY ==========
// ~67k common English words (SCOWL size 55), gzip compressed + base64 encoded
// Dictionary loaded from dictionary.js

let VALID_WORDS = new Set();
let PREFIX_SET = new Set();
let dictionaryReady = false;

async function loadDictionary() {
  try {
    const binary = Uint8Array.from(atob(DICT_GZ_B64), c => c.charCodeAt(0));
    const ds = new DecompressionStream('gzip');
    const writer = ds.writable.getWriter();
    writer.write(binary);
    writer.close();
    const reader = ds.readable.getReader();
    const chunks = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }
    const totalLen = chunks.reduce((a, c) => a + c.length, 0);
    const merged = new Uint8Array(totalLen);
    let offset = 0;
    for (const chunk of chunks) {
      merged.set(chunk, offset);
      offset += chunk.length;
    }
    const csv = new TextDecoder().decode(merged);
    const words = csv.split(',');
    VALID_WORDS = new Set(words);
    
    // Build prefix set for fast DFS pruning
    PREFIX_SET = new Set();
    for (const word of words) {
      for (let i = 1; i <= word.length; i++) {
        PREFIX_SET.add(word.substring(0, i));
      }
    }
    
    dictionaryReady = true;
    console.log('Dictionary loaded:', VALID_WORDS.size, 'words,', PREFIX_SET.size, 'prefixes');
  } catch (e) {
    console.error('Dict load failed:', e);
  }
}

// ========== BOARD GENERATION ==========
// Classic Boggle dice - carefully designed letter distributions
const BOGGLE_DICE_4x4 = [
  'AAEEGN','ABBJOO','ACHOPS','AFFKPS',
  'AOOTTW','CIMOTU','DEILRX','DELRVY',
  'DISTTY','EEGHNW','EEINSU','EHRTVW',
  'EIOSST','ELRTTY','HIMNUQ','HLNNRZ'
];
const BOGGLE_DICE_5x5 = [
  'AAAFRS','AAEEEE','AAFIRS','ADENNN','AEEEEM',
  'AEEGMU','AEGMNN','AFIRSY','BJKQXZ','CCNSTW',
  'CEIILT','CEILPT','CEIPST','DDLNOR','DHHLOR',
  'DHHNOT','DHLNOR','EIIITT','EMOTTT','ENSSSU',
  'FIPRSY','GORRVW','HIPRRY','NOOTUW','OOOTTU'
];
// 6x6: combine 5x5 dice + extra dice with good letter distributions
const BOGGLE_DICE_6x6 = [
  ...BOGGLE_DICE_5x5,
  'AAAFRS','AEEGMU','CEIILT','EMOTTT','ENSSSU',
  'ADENNN','DHLNOR','EIIITT','GORRVW','NOOTUW',
  'DHHLOR'
];

function rollDice(diceSet, count) {
  const shuffled = [...diceSet].sort(() => Math.random() - 0.5);
  const board = [];
  for (let i = 0; i < count; i++) {
    const die = shuffled[i % shuffled.length];
    board.push(die[Math.floor(Math.random() * die.length)]);
  }
  return board;
}

// Configurable settings
let GRID_SIZE = 5;
let MIN_WORD_LENGTH = 4;

function generateBoard() {
  const totalTiles = GRID_SIZE * GRID_SIZE;
  const diceSet = GRID_SIZE === 4 ? BOGGLE_DICE_4x4 : GRID_SIZE === 5 ? BOGGLE_DICE_5x5 : BOGGLE_DICE_6x6;
  
  // Generate multiple boards and pick the one with the most words
  // Fewer candidates for larger grids since each solve is heavier
  let bestBoard = null;
  let bestWordCount = 0;
  const attempts = GRID_SIZE === 4 ? 25 : GRID_SIZE === 5 ? 15 : 8;
  
  for (let i = 0; i < attempts; i++) {
    const candidate = rollDice(diceSet, totalTiles);
    const result = findAllWords(candidate);
    if (result.words.size > bestWordCount) {
      bestWordCount = result.words.size;
      bestBoard = candidate;
    }
  }
  
  console.log('Board generated with', bestWordCount, 'possible words');
  return bestBoard;
}

function getNeighbors(idx) {
  const r = Math.floor(idx / GRID_SIZE), c = idx % GRID_SIZE;
  const neighbors = [];
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) neighbors.push(nr * GRID_SIZE + nc);
    }
  }
  return neighbors;
}

function buildNeighborMap() {
  const totalTiles = GRID_SIZE * GRID_SIZE;
  const map = [];
  for (let i = 0; i < totalTiles; i++) map.push(getNeighbors(i));
  return map;
}

let NEIGHBOR_MAP = buildNeighborMap();

function findAllWords(board) {
  const found = new Set();
  const wordPaths = {};
  const totalTiles = GRID_SIZE * GRID_SIZE;

  function dfs(idx, path, word) {
    const letter = board[idx].toLowerCase();
    word += letter === 'q' ? 'qu' : letter;
    // Prune: if no words start with this prefix, stop exploring
    if (!PREFIX_SET.has(word)) return;
    if (word.length >= MIN_WORD_LENGTH && VALID_WORDS.has(word)) {
      if (!found.has(word)) {
        found.add(word);
        wordPaths[word] = [...path];
      }
    }
    if (word.length >= 8) return;
    for (const n of NEIGHBOR_MAP[idx]) {
      if (!path.has(n)) {
        path.add(n);
        dfs(n, path, word);
        path.delete(n);
      }
    }
  }

  for (let i = 0; i < totalTiles; i++) {
    const path = new Set([i]);
    dfs(i, path, '');
  }
  return { words: found, paths: wordPaths };
}

// ========== SCORING ==========
function scoreWord(word) {
  const len = word.length;
  if (len <= 3) return 1;
  if (len === 4) return 1;
  if (len === 5) return 2;
  if (len === 6) return 3;
  if (len === 7) return 5;
  return 11;
}

// ========== GAME STATE ==========
let board = [];
let validWordsOnBoard = new Set();
let allWordPaths = {};
let foundWords = new Set();
let selectedPath = [];
let isSelecting = false;
let totalScore = 0;
let timerSeconds = 30;
let timerInterval = null;
let gameActive = false;

// ========== AUDIO ==========
let audioCtx = null;
let musicPlaying = false;
let musicNodes = [];

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTick() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Percussive click: short noise burst + pitched blip
  const bufferSize = audioCtx.sampleRate * 0.015;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 8);
  }
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.12, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = 'bandpass';
  noiseFilter.frequency.value = 4000;
  noiseFilter.Q.value = 1.5;
  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noise.start(now);
  noise.stop(now + 0.02);

  // Tonal blip
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.setValueAtTime(880 + Math.random() * 300, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.04);
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
  osc.start(now);
  osc.stop(now + 0.05);
}

function playValidSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Bright ascending arpeggio with harmonics
  const notes = [523, 659, 784, 1047];
  notes.forEach((freq, i) => {
    const t = now + i * 0.045;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = 'triangle';
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc.start(t);
    osc.stop(t + 0.2);
  });
  // Satisfying shimmer
  const shimmer = audioCtx.createOscillator();
  const sGain = audioCtx.createGain();
  shimmer.connect(sGain);
  sGain.connect(audioCtx.destination);
  shimmer.frequency.value = 1568;
  shimmer.type = 'sine';
  sGain.gain.setValueAtTime(0.04, now + 0.12);
  sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  shimmer.start(now + 0.12);
  shimmer.stop(now + 0.5);
}

function playInvalidSound() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Dull thud
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.setValueAtTime(150, now);
  osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.12, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
  osc.start(now);
  osc.stop(now + 0.13);
}

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;

  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.18;
  masterGain.connect(audioCtx.destination);
  musicNodes.push(masterGain);

  // Chord progression: Am - F - C - G (looping)
  const chords = [
    [220.0, 261.6, 329.6],   // Am
    [174.6, 220.0, 261.6],   // F
    [130.8, 164.8, 196.0],   // C low
    [196.0, 246.9, 293.7],   // G
  ];

  const bpm = 72;
  const beatDur = 60 / bpm;
  const chordDur = beatDur * 4; // 4 beats per chord
  const loopDur = chordDur * chords.length;

  // Soft pad layer
  function schedulePad() {
    const now = audioCtx.currentTime;
    chords.forEach((notes, ci) => {
      const startT = now + ci * chordDur;
      notes.forEach(freq => {
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq * 0.5;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0, startT);
        g.gain.linearRampToValueAtTime(0.25, startT + 0.4);
        g.gain.setValueAtTime(0.25, startT + chordDur - 0.4);
        g.gain.linearRampToValueAtTime(0, startT + chordDur);
        osc.connect(g);
        g.connect(masterGain);
        osc.start(startT);
        osc.stop(startT + chordDur + 0.1);
        musicNodes.push(osc, g);
      });
    });
  }

  // Arpeggio layer — gentle plucked notes
  function scheduleArpeggio() {
    const now = audioCtx.currentTime;
    const arpPatterns = [
      [440, 523.3, 659.3, 523.3, 440, 523.3, 659.3, 523.3],     // Am
      [349.2, 440, 523.3, 440, 349.2, 440, 523.3, 440],          // F
      [261.6, 329.6, 392, 329.6, 261.6, 329.6, 392, 329.6],      // C
      [392, 493.9, 587.3, 493.9, 392, 493.9, 587.3, 493.9],      // G
    ];
    arpPatterns.forEach((pattern, ci) => {
      const chordStart = now + ci * chordDur;
      pattern.forEach((freq, ni) => {
        const t = chordStart + ni * (chordDur / pattern.length);
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + beatDur * 1.2);
        osc.connect(g);
        g.connect(masterGain);
        osc.start(t);
        osc.stop(t + beatDur * 1.5);
        musicNodes.push(osc, g);
      });
    });
  }

  // Subtle bass note per chord
  function scheduleBass() {
    const now = audioCtx.currentTime;
    const bassNotes = [110, 87.3, 65.4, 98];
    bassNotes.forEach((freq, ci) => {
      const t = now + ci * chordDur;
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.3, t);
      g.gain.exponentialRampToValueAtTime(0.05, t + chordDur * 0.8);
      g.gain.linearRampToValueAtTime(0, t + chordDur);
      osc.connect(g);
      g.connect(masterGain);
      osc.start(t);
      osc.stop(t + chordDur + 0.1);
      musicNodes.push(osc, g);
    });
  }

  // Schedule first loop
  schedulePad();
  scheduleArpeggio();
  scheduleBass();

  // Re-schedule on loop
  musicLoopInterval = setInterval(() => {
    if (!musicPlaying) return;
    schedulePad();
    scheduleArpeggio();
    scheduleBass();
  }, loopDur * 1000);
  musicNodes.push({ stop: () => clearInterval(musicLoopInterval) });
}

let musicLoopInterval = null;

function stopMusic() {
  musicPlaying = false;
  clearInterval(musicLoopInterval);
  musicNodes.forEach(n => { try { n.stop ? n.stop() : n.disconnect(); } catch(e){} });
  musicNodes = [];
}

// ========== HAPTICS ==========
function hapticTick() {
  if (navigator.vibrate) navigator.vibrate(8);
}
function hapticSuccess() {
  if (navigator.vibrate) navigator.vibrate([15, 30, 15]);
}
function hapticError() {
  if (navigator.vibrate) navigator.vibrate([40]);
}

// ========== DOM ==========
const boardEl = document.getElementById('board');
const pathSvg = document.getElementById('pathSvg');
const currentWordEl = document.getElementById('currentWord');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const toastEl = document.getElementById('toast');
const startScreen = document.getElementById('startScreen');
const endScreen = document.getElementById('endScreen');
const gameUI = document.getElementById('gameUI');
const wordArea = document.getElementById('wordArea');
const boardContainer = document.getElementById('boardContainer');
const musicToggle = document.getElementById('musicToggle');

function renderBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  // Adjust gap and font size for grid density
  const gaps = { 4: 14, 5: 12, 6: 8 };
  const fonts = { 4: 24, 5: 22, 6: 18 };
  boardEl.style.gap = (gaps[GRID_SIZE] || 10) + 'px';
  board.forEach((letter, i) => {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.style.fontSize = (fonts[GRID_SIZE] || 20) + 'px';
    tile.textContent = letter === 'Q' ? 'Qu' : letter;
    tile.dataset.index = i;
    boardEl.appendChild(tile);
  });
}

function getTileCenter(idx) {
  const tile = boardEl.children[idx];
  if (!tile) return { x: 0, y: 0 };
  const boardRect = boardContainer.getBoundingClientRect();
  const tileRect = tile.getBoundingClientRect();
  return {
    x: ((tileRect.left + tileRect.width / 2 - boardRect.left) / boardRect.width) * 100 + '%',
    y: ((tileRect.top + tileRect.height / 2 - boardRect.top) / boardRect.height) * 100 + '%'
  };
}

function updatePathSvg() {
  pathSvg.innerHTML = '';
  for (let i = 1; i < selectedPath.length; i++) {
    const from = getTileCenter(selectedPath[i - 1]);
    const to = getTileCenter(selectedPath[i]);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', from.x);
    line.setAttribute('y1', from.y);
    line.setAttribute('x2', to.x);
    line.setAttribute('y2', to.y);
    pathSvg.appendChild(line);
  }
}

let prevSelectedSet = new Set();

function updateSelection() {
  const tiles = boardEl.children;
  const selectedSet = new Set(selectedPath);

  for (let i = 0; i < tiles.length; i++) {
    const wasSelected = prevSelectedSet.has(i);
    const isSelected = selectedSet.has(i);
    tiles[i].classList.toggle('selected', isSelected);

    if (isSelected && !wasSelected) {
      // Newly selected — pop in
      tiles[i].classList.remove('unpop');
      tiles[i].classList.remove('pop');
      void tiles[i].offsetWidth; // force reflow
      tiles[i].classList.add('pop');
    } else if (!isSelected && wasSelected) {
      // Deselected — pop out
      tiles[i].classList.remove('pop');
      tiles[i].classList.remove('unpop');
      void tiles[i].offsetWidth;
      tiles[i].classList.add('unpop');
    }
  }

  prevSelectedSet = new Set(selectedSet);
  const word = selectedPath.map(i => board[i] === 'Q' ? 'QU' : board[i]).join('');
  currentWordEl.textContent = word;
  updatePathSvg();
}

function getTileFromPoint(x, y) {
  const tiles = boardEl.children;
  for (let i = 0; i < tiles.length; i++) {
    const rect = tiles[i].getBoundingClientRect();
    // Inset the hit target so edges don't trigger — helps diagonal swiping
    const inset = rect.width * 0.12;
    if (x >= rect.left + inset && x <= rect.right - inset && y >= rect.top + inset && y <= rect.bottom - inset) {
      return i;
    }
  }
  return -1;
}

function isAdjacent(a, b) {
  return NEIGHBOR_MAP[a].includes(b);
}

// ========== INPUT HANDLING ==========
function onSelectStart(x, y) {
  if (!gameActive) return;
  const idx = getTileFromPoint(x, y);
  if (idx < 0) return;
  isSelecting = true;
  selectedPath = [idx];
  playTick();
  updateSelection();
}

function onSelectMove(x, y) {
  if (!isSelecting || !gameActive) return;
  const idx = getTileFromPoint(x, y);
  if (idx < 0) return;

  const lastIdx = selectedPath[selectedPath.length - 1];
  if (idx === lastIdx) return;

  // Allow backtracking
  if (selectedPath.length >= 2 && idx === selectedPath[selectedPath.length - 2]) {
    selectedPath.pop();
    playTick();
    updateSelection();
    return;
  }

  if (selectedPath.includes(idx)) return;
  if (!isAdjacent(lastIdx, idx)) return;

  selectedPath.push(idx);
  playTick();
  updateSelection();
}

function onSelectEnd() {
  if (!isSelecting || !gameActive) return;
  isSelecting = false;
  submitWord();
}

let resultTimeout = null;

function showTileResult(indices, resultClass) {
  clearTimeout(resultTimeout);
  const tiles = boardEl.children;

  // Apply result state to the selected tiles
  indices.forEach(idx => {
    tiles[idx].classList.remove('pop', 'unpop', 'selected');
    tiles[idx].classList.add(resultClass);
  });

  // After animation, fade back to default
  resultTimeout = setTimeout(() => {
    indices.forEach(idx => {
      tiles[idx].classList.add('result-fade');
      tiles[idx].classList.remove(resultClass);
    });
    // Clean up transition class
    setTimeout(() => {
      indices.forEach(idx => {
        tiles[idx].classList.remove('result-fade');
      });
    }, 300);
  }, 350);
}

function submitWord() {
  const word = selectedPath.map(i => board[i] === 'Q' ? 'QU' : board[i]).join('').toLowerCase();
  const submittedPath = [...selectedPath];
  prevSelectedSet = new Set();
  selectedPath = [];
  currentWordEl.textContent = '';
  updatePathSvg();

  // Clear selection styling (but don't unpop — we'll show result state instead)
  const tiles = boardEl.children;
  for (let i = 0; i < tiles.length; i++) {
    tiles[i].classList.remove('selected', 'pop', 'unpop');
  }

  if (word.length < 3) return;

  if (word.length < MIN_WORD_LENGTH) {
    showToast(`${MIN_WORD_LENGTH} letters min`, 'invalid');
    showTileResult(submittedPath, 'result-invalid');
    playInvalidSound();
    return;
  }

  if (foundWords.has(word)) {
    showToast('Already found', 'duplicate');
    showTileResult(submittedPath, 'result-duplicate');
    playInvalidSound();
    return;
  }

  if (validWordsOnBoard.has(word)) {
    foundWords.add(word);
    const pts = scoreWord(word);
    totalScore += pts;
    scoreEl.textContent = totalScore;
    scoreEl.classList.remove('bump');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('bump');
    showToast(`+${pts}`, 'valid');
    showTileResult(submittedPath, 'result-valid');
    playValidSound();
  } else {
    showToast('Not a word', 'invalid');
    showTileResult(submittedPath, 'result-invalid');
    playInvalidSound();
  }
}

let toastTimeout = null;
function showToast(msg, type) {
  clearTimeout(toastTimeout);
  // Position above the board
  const boardRect = boardContainer.getBoundingClientRect();
  toastEl.style.top = (boardRect.top - 70) + 'px';
  toastEl.className = 'feedback-toast ' + type;
  toastEl.textContent = msg;
  toastEl.offsetHeight;
  toastEl.classList.add('show');

  toastTimeout = setTimeout(() => {
    toastEl.classList.remove('show');
    toastEl.classList.add('hide');
  }, 600);
}

// Touch events
boardContainer.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  onSelectStart(t.clientX, t.clientY);
}, { passive: false });

boardContainer.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  onSelectMove(t.clientX, t.clientY);
}, { passive: false });

boardContainer.addEventListener('touchend', e => {
  e.preventDefault();
  onSelectEnd();
}, { passive: false });

// Mouse events (for desktop)
boardContainer.addEventListener('mousedown', e => {
  onSelectStart(e.clientX, e.clientY);
});
window.addEventListener('mousemove', e => {
  onSelectMove(e.clientX, e.clientY);
});
window.addEventListener('mouseup', () => {
  onSelectEnd();
});

// ========== TIMER ==========
function updateTimerDisplay() {
  const m = Math.floor(timerSeconds / 60);
  const s = timerSeconds % 60;
  timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  timerEl.classList.toggle('urgent', timerSeconds <= 15);
}

function startTimer() {
  updateTimerDisplay();
  timerInterval = setInterval(() => {
    timerSeconds--;
    updateTimerDisplay();
    if (timerSeconds <= 0) {
      endGame();
    }
  }, 1000);
}

// ========== GAME FLOW ==========
async function startGame() {
  initAudio();

  let gameDuration;

  if (challengeMode && currentChallengeData) {
    // Challenge mode: use settings from Firestore
    GRID_SIZE = currentChallengeData.gridSize;
    MIN_WORD_LENGTH = currentChallengeData.minWordLength;
    gameDuration = currentChallengeData.timeSeconds;
  } else {
    // Solo mode: read settings from UI
    const gridBtn = document.querySelector('#startScreen:not(.hidden) #gridOptions button.active, #newGameModal:not(.hidden) #gridOptions2 button.active');
    const minBtn = document.querySelector('#startScreen:not(.hidden) #minWordOptions button.active, #newGameModal:not(.hidden) #minWordOptions2 button.active');
    const timeBtn = document.querySelector('#startScreen:not(.hidden) #timeOptions button.active, #newGameModal:not(.hidden) #timeOptions2 button.active');
    GRID_SIZE = parseInt(gridBtn?.dataset.val || '5');
    MIN_WORD_LENGTH = parseInt(minBtn?.dataset.val || '4');
    gameDuration = parseInt(timeBtn?.dataset.val || '30');
  }

  NEIGHBOR_MAP = buildNeighborMap();

  // Sync both setting screens
  document.querySelectorAll('#gridOptions button, #gridOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(GRID_SIZE));
  });
  document.querySelectorAll('#minWordOptions button, #minWordOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(MIN_WORD_LENGTH));
  });
  document.querySelectorAll('#timeOptions button, #timeOptions2 button').forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(gameDuration));
  });

  // Load dictionary on first play
  if (!dictionaryReady) {
    document.getElementById('startBtn').textContent = 'Loading...';
    document.getElementById('replayBtn').textContent = 'Loading...';
    await loadDictionary();
    document.getElementById('startBtn').textContent = 'Play';
    document.getElementById('replayBtn').textContent = 'Play';
  }

  // Hide all overlays
  startScreen.classList.add('hidden');
  endScreen.classList.add('hidden');
  document.getElementById('newGameModal').classList.add('hidden');
  document.getElementById('challengeCreatedScreen').classList.add('hidden');
  document.getElementById('challengeLobbyScreen').classList.add('hidden');
  document.getElementById('challengeEndScreen').classList.add('hidden');
  document.getElementById('challengeErrorScreen').classList.add('hidden');
  gameUI.style.visibility = 'visible';
  wordArea.style.visibility = 'visible';
  boardContainer.style.visibility = 'visible';

  if (challengeMode && currentChallengeData) {
    // Use board from challenge data
    board = currentChallengeData.board;
  } else {
    board = generateBoard();
  }

  const solveResult = findAllWords(board);
  validWordsOnBoard = solveResult.words;
  allWordPaths = solveResult.paths;
  foundWords = new Set();
  selectedPath = [];
  prevSelectedSet = new Set();
  totalScore = 0;
  timerSeconds = gameDuration;
  scoreEl.textContent = '0';

  renderBoard();
  startTimer();
  startMusic();
  gameActive = true;
}

function endGame() {
  gameActive = false;
  clearInterval(timerInterval);
  stopMusic();

  gameUI.style.visibility = 'hidden';
  wordArea.style.visibility = 'hidden';
  boardContainer.style.visibility = 'hidden';

  if (challengeMode && currentChallengeId) {
    endChallengeGame();
    return;
  }

  // Solo mode end screen
  showSoloEndScreen();
}

function showSoloEndScreen() {
  document.getElementById('endScore').textContent = totalScore;
  const totalPossible = validWordsOnBoard.size;
  document.getElementById('endRatio').textContent = `${foundWords.size}/${totalPossible} words`;

  const container = document.getElementById('accordionContainer');
  container.innerHTML = '';
  buildWordAccordion(container, validWordsOnBoard, foundWords);
  endScreen.classList.remove('hidden');
}

function buildWordAccordion(container, allWords, myWords, theirWords) {
  const isComparison = !!theirWords;
  const byLength = {};
  for (const w of allWords) {
    const len = w.length;
    if (len < MIN_WORD_LENGTH) continue;
    if (!byLength[len]) byLength[len] = [];
    byLength[len].push(w);
  }

  const lengths = Object.keys(byLength).map(Number).sort((a, b) => a - b);

  lengths.forEach(len => {
    const words = byLength[len].sort();
    const foundInGroup = words.filter(w => myWords.has(w));
    const section = document.createElement('div');
    section.className = 'accordion-section';

    const header = document.createElement('div');
    header.className = 'accordion-header';
    header.innerHTML = `
      <div class="accordion-header-left">
        <span class="accordion-header-label">${len}-letter</span>
        <span class="accordion-header-count">${foundInGroup.length}/${words.length}</span>
      </div>
      <div class="accordion-chevron"></div>
    `;
    header.addEventListener('click', () => section.classList.toggle('open'));

    const body = document.createElement('div');
    body.className = 'accordion-body';

    words.forEach(w => {
      const chip = document.createElement('span');
      if (isComparison) {
        const iFound = myWords.has(w);
        const theyFound = theirWords.has(w);
        if (iFound && theyFound) chip.className = 'accordion-word both-found';
        else if (iFound) chip.className = 'accordion-word only-me';
        else if (theyFound) chip.className = 'accordion-word only-them';
        else chip.className = 'accordion-word neither';
      } else {
        chip.className = 'accordion-word ' + (myWords.has(w) ? 'found' : 'missed');
      }
      chip.textContent = w;
      if (!myWords.has(w) && (!theirWords || !theirWords.has(w))) {
        chip.addEventListener('click', () => showWordPath(w));
      }
      body.appendChild(chip);
    });

    section.appendChild(header);
    section.appendChild(body);
    container.appendChild(section);
  });
}

// ========== CHALLENGE MODE FUNCTIONS ==========

async function createChallenge() {
  const gridBtn = document.querySelector('#startScreen #gridOptions button.active');
  const minBtn = document.querySelector('#startScreen #minWordOptions button.active');
  const timeBtn = document.querySelector('#startScreen #timeOptions button.active');
  const gridSize = parseInt(gridBtn?.dataset.val || '5');
  const minWordLength = parseInt(minBtn?.dataset.val || '4');
  const timeSeconds = parseInt(timeBtn?.dataset.val || '30');

  // Set globals for board generation
  GRID_SIZE = gridSize;
  MIN_WORD_LENGTH = minWordLength;
  NEIGHBOR_MAP = buildNeighborMap();

  // Load dictionary if needed
  if (!dictionaryReady) {
    document.getElementById('challengeBtn').textContent = 'Loading...';
    await loadDictionary();
    document.getElementById('challengeBtn').textContent = 'Challenge a Friend';
  }

  // Generate board
  const challengeBoard = generateBoard();
  const solveResult = findAllWords(challengeBoard);

  // Create Firestore document
  const docRef = await db.collection('challenges').add({
    board: challengeBoard,
    gridSize: gridSize,
    minWordLength: minWordLength,
    timeSeconds: timeSeconds,
    totalValidWords: solveResult.words.size,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    players: {}
  });

  currentChallengeId = docRef.id;
  currentChallengeData = {
    board: challengeBoard,
    gridSize: gridSize,
    minWordLength: minWordLength,
    timeSeconds: timeSeconds,
    totalValidWords: solveResult.words.size,
    players: {}
  };
  challengeMode = true;

  // Build shareable link
  const url = `${location.origin}${location.pathname}?c=${docRef.id}`;
  document.getElementById('challengeLink').value = url;

  // Show challenge created screen
  startScreen.classList.add('hidden');
  document.getElementById('challengeCreatedScreen').classList.remove('hidden');
}

async function joinChallenge(challengeId) {
  try {
    const doc = await db.collection('challenges').doc(challengeId).get();
    if (!doc.exists) {
      showChallengeError('Challenge not found');
      return;
    }

    const data = doc.data();
    currentChallengeId = challengeId;
    currentChallengeData = data;
    challengeMode = true;

    // Check if this player already played
    if (data.players && data.players[MY_PLAYER_ID]) {
      // Already played — show results
      showChallengeResults(data);
      return;
    }

    // Check if 2 players already played
    const playerIds = data.players ? Object.keys(data.players) : [];
    if (playerIds.length >= 2) {
      showChallengeError('This challenge is full');
      return;
    }

    // Show lobby
    const m = Math.floor(data.timeSeconds / 60);
    const s = data.timeSeconds % 60;
    document.getElementById('lobbyGrid').textContent = `${data.gridSize}×${data.gridSize}`;
    document.getElementById('lobbyMinWord').textContent = data.minWordLength;
    document.getElementById('lobbyTime').textContent = `${m}:${s.toString().padStart(2, '0')}`;

    startScreen.classList.add('hidden');
    document.getElementById('challengeLobbyScreen').classList.remove('hidden');
  } catch (err) {
    console.error('Join challenge error:', err);
    showChallengeError('Failed to load challenge. Please try again.');
  }
}

function showChallengeError(msg) {
  document.getElementById('challengeErrorMsg').textContent = msg;
  startScreen.classList.add('hidden');
  document.getElementById('challengeErrorScreen').classList.remove('hidden');
}

async function endChallengeGame() {
  // Write results to Firestore
  const myResult = {
    score: totalScore,
    wordsFound: [...foundWords],
    wordCount: foundWords.size,
    completedAt: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await db.collection('challenges').doc(currentChallengeId).update({
      [`players.${MY_PLAYER_ID}`]: myResult
    });
  } catch (err) {
    console.error('Failed to save results:', err);
  }

  // Fetch latest state
  const doc = await db.collection('challenges').doc(currentChallengeId).get();
  const data = doc.data();
  currentChallengeData = data;

  showChallengeResults(data);
}

function showChallengeResults(data) {
  const challengeEndEl = document.getElementById('challengeEndScreen');
  const waitingEl = document.getElementById('challengeWaiting');
  const compEl = document.getElementById('challengeComparison');

  const myData = data.players?.[MY_PLAYER_ID];
  const opponentId = Object.keys(data.players || {}).find(id => id !== MY_PLAYER_ID);
  const opponentData = opponentId ? data.players[opponentId] : null;

  // Set up validWordsOnBoard if not already (for comparison accordion word paths)
  if (!validWordsOnBoard || validWordsOnBoard.size === 0) {
    GRID_SIZE = data.gridSize;
    MIN_WORD_LENGTH = data.minWordLength;
    NEIGHBOR_MAP = buildNeighborMap();
    board = data.board;
    const solveResult = findAllWords(board);
    validWordsOnBoard = solveResult.words;
    allWordPaths = solveResult.paths;
  }

  if (opponentData) {
    // Show comparison
    waitingEl.classList.add('hidden');
    compEl.classList.remove('hidden');
    renderComparison(myData, opponentData, data);
  } else {
    // Show waiting state
    waitingEl.classList.remove('hidden');
    compEl.classList.add('hidden');

    document.getElementById('challengeMyScore').textContent = myData?.score || totalScore;
    document.getElementById('challengeMyRatio').textContent =
      `${myData?.wordCount || foundWords.size}/${data.totalValidWords} words`;

    // Listen for opponent
    if (challengeUnsubscribe) challengeUnsubscribe();
    challengeUnsubscribe = db.collection('challenges').doc(currentChallengeId)
      .onSnapshot(snap => {
        const updated = snap.data();
        const oppId = Object.keys(updated.players || {}).find(id => id !== MY_PLAYER_ID);
        if (oppId && updated.players[oppId]) {
          if (challengeUnsubscribe) challengeUnsubscribe();
          challengeUnsubscribe = null;
          currentChallengeData = updated;
          waitingEl.classList.add('hidden');
          compEl.classList.remove('hidden');
          renderComparison(updated.players[MY_PLAYER_ID], updated.players[oppId], updated);
        }
      });
  }

  challengeEndEl.classList.remove('hidden');
}

function renderComparison(myData, theirData, challengeData) {
  document.getElementById('compMyScore').textContent = myData.score;
  document.getElementById('compMyWords').textContent = `${myData.wordCount} words`;
  document.getElementById('compTheirScore').textContent = theirData.score;
  document.getElementById('compTheirWords').textContent = `${theirData.wordCount} words`;

  const resultEl = document.getElementById('compResult');
  if (myData.score > theirData.score) {
    resultEl.textContent = 'You win!';
    resultEl.className = 'comparison-result win';
  } else if (myData.score < theirData.score) {
    resultEl.textContent = 'You lose';
    resultEl.className = 'comparison-result lose';
  } else {
    resultEl.textContent = "It's a tie!";
    resultEl.className = 'comparison-result tie';
  }

  // Build comparison accordion
  const container = document.getElementById('challengeAccordionContainer');
  container.innerHTML = '';

  const myWords = new Set(myData.wordsFound || []);
  const theirWords = new Set(theirData.wordsFound || []);

  buildWordAccordion(container, validWordsOnBoard, myWords, theirWords);
}

// ========== URL HANDLING ==========
function checkUrlForChallenge() {
  const params = new URLSearchParams(window.location.search);
  const challengeId = params.get('c');
  if (challengeId) {
    joinChallenge(challengeId);
  }
}

// ========== WORD PATH MODAL ==========
function showWordPath(word) {
  const modal = document.getElementById('wordModal');
  const modalBoard = document.getElementById('modalBoard');
  const modalSvg = document.getElementById('modalPathSvg');
  const modalTitle = document.getElementById('wordModalTitle');
  const boardWrap = document.querySelector('.word-modal-board-wrap');

  modalTitle.textContent = word.toUpperCase();

  // Render mini board
  modalBoard.innerHTML = '';
  modalBoard.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  const gaps = { 4: 10, 5: 8, 6: 6 };
  const fonts = { 4: 18, 5: 16, 6: 13 };
  modalBoard.style.gap = (gaps[GRID_SIZE] || 8) + 'px';

  const path = allWordPaths[word] || [];
  const pathSet = new Set(path);

  board.forEach((letter, i) => {
    const tile = document.createElement('div');
    tile.className = 'tile' + (pathSet.has(i) ? ' path-highlight' : '');
    tile.style.fontSize = (fonts[GRID_SIZE] || 14) + 'px';
    tile.textContent = letter === 'Q' ? 'Qu' : letter;
    modalBoard.appendChild(tile);
  });

  // Draw path lines
  modalSvg.innerHTML = '';
  requestAnimationFrame(() => {
    const wrapRect = boardWrap.getBoundingClientRect();
    for (let i = 1; i < path.length; i++) {
      const fromTile = modalBoard.children[path[i - 1]];
      const toTile = modalBoard.children[path[i]];
      if (!fromTile || !toTile) continue;
      const fromRect = fromTile.getBoundingClientRect();
      const toRect = toTile.getBoundingClientRect();
      const x1 = ((fromRect.left + fromRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y1 = ((fromRect.top + fromRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const x2 = ((toRect.left + toRect.width / 2 - wrapRect.left) / wrapRect.width) * 100 + '%';
      const y2 = ((toRect.top + toRect.height / 2 - wrapRect.top) / wrapRect.height) * 100 + '%';
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      modalSvg.appendChild(line);
    }
  });

  modal.classList.remove('hidden');
}

document.getElementById('wordModalBackdrop').addEventListener('click', () => {
  document.getElementById('wordModal').classList.add('hidden');
});
document.getElementById('wordModalClose').addEventListener('click', () => {
  document.getElementById('wordModal').classList.add('hidden');
});

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('replayBtn').addEventListener('click', () => {
  startGame();
});

// Play again trigger opens new game modal
document.getElementById('playAgainTrigger').addEventListener('click', () => {
  document.getElementById('newGameModal').classList.remove('hidden');
});
document.getElementById('newGameModalBackdrop').addEventListener('click', () => {
  document.getElementById('newGameModal').classList.add('hidden');
});

// Settings toggle behavior
document.querySelectorAll('.setting-options').forEach(group => {
  group.addEventListener('click', e => {
    const btn = e.target.closest('button');
    if (!btn) return;
    group.querySelectorAll('button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

musicToggle.addEventListener('click', () => {
  if (musicPlaying) {
    stopMusic();
    musicToggle.textContent = '♪';
    musicToggle.style.opacity = '0.4';
  } else if (gameActive) {
    initAudio();
    startMusic();
    musicToggle.textContent = '♪';
    musicToggle.style.opacity = '1';
  }
});

// ========== CHALLENGE EVENT LISTENERS ==========
document.getElementById('challengeBtn').addEventListener('click', async () => {
  document.getElementById('challengeBtn').textContent = 'Creating...';
  try {
    await createChallenge();
  } catch (err) {
    console.error('Create challenge error:', err);
    showChallengeError('Failed to create challenge. Please try again.');
  }
  document.getElementById('challengeBtn').textContent = 'Challenge a Friend';
});

document.getElementById('copyLinkBtn').addEventListener('click', () => {
  const input = document.getElementById('challengeLink');
  navigator.clipboard.writeText(input.value).then(() => {
    document.getElementById('copyLinkBtn').textContent = 'Copied!';
    setTimeout(() => {
      document.getElementById('copyLinkBtn').textContent = 'Copy';
    }, 2000);
  });
});

document.getElementById('playOwnChallengeBtn').addEventListener('click', () => {
  startGame();
});

document.getElementById('lobbyStartBtn').addEventListener('click', () => {
  startGame();
});

document.getElementById('challengePlayAgain').addEventListener('click', () => {
  // Clean up challenge state
  challengeMode = false;
  currentChallengeId = null;
  currentChallengeData = null;
  if (challengeUnsubscribe) {
    challengeUnsubscribe();
    challengeUnsubscribe = null;
  }
  // Clear URL params
  history.replaceState(null, '', location.pathname);
  // Hide challenge screens, show start
  document.getElementById('challengeEndScreen').classList.add('hidden');
  startScreen.classList.remove('hidden');
});

document.getElementById('challengeErrorHomeBtn').addEventListener('click', () => {
  challengeMode = false;
  currentChallengeId = null;
  currentChallengeData = null;
  history.replaceState(null, '', location.pathname);
  document.getElementById('challengeErrorScreen').classList.add('hidden');
  startScreen.classList.remove('hidden');
});

// Check URL for challenge on page load
checkUrlForChallenge();
</script>
</body>
</html>
